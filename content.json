{"meta":{"title":"虾爬子的Blog","subtitle":null,"description":"虾爬子,佟子琦，博客，马千寓","author":"Tongziqi","url":"https://createralan.github.io"},"pages":[{"title":"微信公众号javaweb全栈之路","date":"2020-11-25T02:51:30.649Z","updated":"2020-11-25T02:51:30.649Z","comments":false,"path":"about/index.html","permalink":"https://createralan.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-25T02:51:30.649Z","updated":"2020-11-25T02:51:30.649Z","comments":false,"path":"categories/index.html","permalink":"https://createralan.github.io/categories/index.html","excerpt":"","text":"虾爬子科技"},{"title":"友情链接","date":"2020-11-25T02:51:30.705Z","updated":"2020-11-25T02:51:30.705Z","comments":true,"path":"links/index.html","permalink":"https://createralan.github.io/links/index.html","excerpt":"","text":""},{"title":"前端导航","date":"2020-11-25T02:51:30.705Z","updated":"2020-11-25T02:51:30.705Z","comments":false,"path":"nav/index.html","permalink":"https://createralan.github.io/nav/index.html","excerpt":"","text":"导航"},{"title":"Repositories","date":"2020-11-25T02:51:30.705Z","updated":"2020-11-25T02:51:30.705Z","comments":false,"path":"repository/index.html","permalink":"https://createralan.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-25T02:51:30.705Z","updated":"2020-11-25T02:51:30.705Z","comments":false,"path":"tags/index.html","permalink":"https://createralan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"linux命令行 (三) 事件处理","slug":"linux命令行-三-事件处理","date":"2020-05-16T21:01:02.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/05/16/linux命令行-三-事件处理/","link":"","permalink":"https://createralan.github.io/2020/05/16/linux命令行-三-事件处理/","excerpt":"","text":"一切源自于一篇文章 Command-line Tools can be 235x Faster than your Hadoop Cluster 命令行比集群快235倍？？？ 也许这个说法有些夸大，或者只针对于小部分情况，但是它真实存在。 今天以一个例子来说明如果使用命令行处理事件。 事件样例数据源：一个2G大小的数据，里面包含了100M场围棋棋局。以下是数据格式。 数据地址：github：rozim/ChessData 12345678[Event \"F/S Return Match\"][Site \"Belgrade, Serbia Yugoslavia|JUG\"][Date \"1992.11.04\"][Round \"29\"][White \"Fischer, Robert J.\"][Black \"Spassky, Boris V.\"][Result \"1/2-1/2\"](moves from the game follow...) 目标：有n个pgn文件里面包含了以上数据格式的复盘数据，每个文件中包含了n个棋局，数据中Result代表黑白棋的输赢，”[黑-白]”。统计白棋、黑棋、和局次数。 一共有三种方式： v1 最简版 1cat *.pgn | grep \"Result\" | sort | uniq -c cat *.pgn : 查看所有pgn格式的文件（文件数量上限通过 $ getconf ARG_MAX 查找） grep “Result”： 搜索所有Result所在行 sort ：排序（时间复杂度O（nlogn），空间复杂度O（n）） uniq -c :统计每个独立行出现的次数，仅对已排序文件有效（时间复杂度O（n），空间复杂度O（1）） 123456//结果样例$ cat *.pgn |grep \"Result\"| sort | uniq -c 159 [Result \"*\"] 839724 [Result \"0-1\"] 966394 [Result \"1/2-1/2\"]1085486 [Result \"1-0\"] v2 优化版 1cat *.pgn | grep \"Result\" | awk '&#123; split($0, a, \"-\"); res = substr(a[1], length(a[1]), 1); if (res == 1) white++; if (res == 0) black++; if (res == 2) draw++;&#125; END &#123; print white+black+draw, white, black, draw &#125;' v3 多线程版 1find . -type f -name '*.pgn' -print0 | xargs -0 -n1 -P8 mawk '/Result/ &#123; split($0, a, \"-\"); res = substr(a[1], length(a[1]), 1); if (res == 1) white++; if (res == 0) black++; if (res == 2) draw++ &#125; END &#123; print white+black+draw, white, black, draw &#125;' | awk '&#123;games += $1; white += $2; black += $3; draw += $4; &#125; END &#123; print games, white, black, draw &#125;' 知识总结 管道中的命令如果没有依赖关系会并行执行 1sleep 3| slepp 5 | echo '8' 会先输出8，过8s多一点点会命令结束 查看磁盘读取时间: time 1time cat*.pgn &gt; /dev/null sort排序 对文本排序，会把所有数据读入内存，如果内存存不下会写入临时文件中 感谢： 原文地址：https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html 技术原文：https://zxi.mytechroad.com/blog/category/linux/","categories":[],"tags":[]},{"title":"JAVA编程基础 （四） switch字符串","slug":"JAVA编程基础-（四）-switch字符串","date":"2020-04-25T23:30:07.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/25/JAVA编程基础-（四）-switch字符串/","link":"","permalink":"https://createralan.github.io/2020/04/25/JAVA编程基础-（四）-switch字符串/","excerpt":"","text":"switch 有时也被划归为一种选择语句。根据整数表达式的值，switch 语句可以从一系列代码中选出一段去执行。它的格式如下： 123456789switch(integral-selector) &#123; case integral-value1 : statement; break; case integral-value2 : statement; break; case integral-value3 : statement; break; case integral-value4 : statement; break; case integral-value5 : statement; break; // ... default: statement;&#125; integral-selector是一个能够产生整数值的表达式，switch能够将整个整个表达式的结果与每个integral-value相比较，若发现相符的，就执行对应的语句，没有发现就执行default语句 switch字符串Java7 加上可字符串switch的用法，下面展示一组传统方法及新方法。 12345678910111213141516171819202122232425262728293031323334353637// control/StringSwitch.javapublic class StringSwitch &#123; public static void main(String[] args) &#123; String color = \"red\"; // 老的方式: 使用 if-then 判断 if(\"red\".equals(color)) &#123; System.out.println(\"RED\"); &#125; else if(\"green\".equals(color)) &#123; System.out.println(\"GREEN\"); &#125; else if(\"blue\".equals(color)) &#123; System.out.println(\"BLUE\"); &#125; else if(\"yellow\".equals(color)) &#123; System.out.println(\"YELLOW\"); &#125; else &#123; System.out.println(\"Unknown\"); &#125; // 新的方法: 字符串搭配 switch switch(color) &#123; case \"red\": System.out.println(\"RED\"); break; case \"green\": System.out.println(\"GREEN\"); break; case \"blue\": System.out.println(\"BLUE\"); break; case \"yellow\": System.out.println(\"YELLOW\"); break; default: System.out.println(\"Unknown\"); break; &#125; &#125;&#125; 一旦理解了 switch，你会明白这其实就是一个逻辑扩展的语法糖。新的编码方式能使得结果更清晰，更易于理解和维护。 作为 switch 字符串的第二个例子，我们重新访问 Math.random()。 它是否产生从 0 到 1 的值，包括还是不包括值 1 呢？在数学术语中，它属于 (0,1)、 [0,1)、(0,1] 、[0,1] 中的哪种呢？（方括号表示“包括”，而括号表示“不包括”） 下面是一个可能提供答案的测试程序。 所有命令行参数都作为 String 对象传递，因此我们可以 switch 参数来决定要做什么。 那么问题来了：如果用户不提供参数 ，索引到 args 的数组就会导致程序失败。 解决这个问题，我们需要预先检查数组的长度，若长度为 0，则使用空字符串 &quot;&quot; 替代；否则，选择 args 数组中的第一个元素： 12345678910111213141516171819202122232425262728// control/RandomBounds.java// Math.random() 会产生 0.0 和 1.0 吗？// &#123;java RandomBounds lower&#125;import onjava.*;public class RandomBounds &#123; public static void main(String[] args) &#123; new TimedAbort(3); switch(args.length == 0 ? \"\" : args[0]) &#123; case \"lower\": while(Math.random() != 0.0) ; // 保持重试 System.out.println(\"Produced 0.0!\"); break; case \"upper\": while(Math.random() != 1.0) ; // 保持重试 System.out.println(\"Produced 1.0!\"); break; default: System.out.println(\"Usage:\"); System.out.println(\"\\tRandomBounds lower\"); System.out.println(\"\\tRandomBounds upper\"); System.exit(1); &#125; &#125;&#125; 要运行该程序，请键入以下任一命令： 123java RandomBounds lower // 或者java RandomBounds upper复制ErrorOK! 使用 onjava 包中的 TimedAbort 类可使程序在三秒后中止。从结果来看，似乎 Math.random() 产生的随机值里不包含 0.0 或 1.0。 这就是该测试容易混淆的地方：若要考虑 0 至 1 之间所有不同 double 数值的可能性，那么这个测试的耗费的时间可能超出一个人的寿命了。 这里我们直接给出正确的结果：Math.random() 的结果集范围包含 0.0 ，不包含 1.0。 在数学术语中，可用 [0,1）来表示。由此可知，我们必须小心分析实验并了解它们的局限性。","categories":[],"tags":[]},{"title":"高效java （十五） 接口优于抽象类","slug":"高效java-（十五）-接口优于抽象类 接口优于抽象类","date":"2020-04-21T19:07:09.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/21/高效java-（十五）-接口优于抽象类 接口优于抽象类/","link":"","permalink":"https://createralan.github.io/2020/04/21/高效java-（十五）-接口优于抽象类 接口优于抽象类/","excerpt":"","text":"接口优于抽象类 Java 有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在 Java 8 [JLS 9.4.3] 中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为 Java 只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。 现有的类可以很容易地进行改进来实现一个新的接口。 你只需添加所需的方法（如果尚不存在的话），并向类声明中添加一个 implements 子句。 例如，当 Comparable, Iterable， 和 Autocloseable 接口添加到 Java 平台时，很多现有类需要实现它们来加以改进。 一般来说，现有的类不能改进以继承一个新的抽象类。 如果你想让两个类继承相同的抽象类，你必须把它放在类型层级结构中的上面位置，它是两个类的祖先。 不幸的是，这会对类型层级结构造成很大的附带损害，迫使新的抽象类的所有后代对它进行子类化，无论这些后代类是否合适。 接口是定义混合类型（mixin）的理想选择。 一般来说，mixin 是一个类，除了它的“主类型”之外，还可以声明它提供了一些可选的行为。 例如，Comparable 是一个类型接口，它允许一个类声明它的实例相对于其他可相互比较的对象是有序的。 这样的接口被称为类型，因为它允许可选功能被“混合”到类型的主要功能。 抽象类不能用于定义混合类，这是因为它们不能被加载到现有的类中：一个类不能有多个父类，并且在类层次结构中没有合理的位置来插入一个类型。 接口允许构建非层级类型的框架。 类型层级对于组织某些事物来说是很好的，但是其他的事物并不是整齐地落入严格的层级结构中。 例如，假设我们有一个代表歌手的接口，和另一个代表作曲家的接口： 1234567public interface Singer &#123; AudioClip sing(Song s);&#125;public interface Songwriter &#123; Song compose(int chartPosition);&#125; 在现实生活中，一些歌手也是作曲家。 因为我们使用接口而不是抽象类来定义这些类型，所以单个类实现歌手和作曲家两个接口是完全允许的。 事实上，我们可以定义一个继承歌手和作曲家的第三个接口，并添加适合于这个组合的新方法： 1234public interface SingerSongwriter extends Singer, Songwriter &#123; AudioClip strum(); void actSensitive();&#125; 你并不总是需要这种灵活性，但是当你这样做的时候，接口是一个救星。 另一种方法是对于每个受支持的属性组合，包含一个单独的类的臃肿类层级结构。 如果类型系统中有 n 个属性，则可能需要支持 2n 种可能的组合。 这就是所谓的组合爆炸（combinatorial explosion）。 臃肿的类层级结构可能会导致具有许多方法的臃肿类，这些方法仅在参数类型上有所不同，因为类层级结构中没有类型来捕获通用行为。 接口通过包装类模式确保安全的，强大的功能增强成为可能（条目 18）。 如果使用抽象类来定义类型，那么就让程序员想要添加功能，只能继承。 生成的类比包装类更弱，更脆弱。 当其他接口方法有明显的接口方法实现时，可以考虑向程序员提供默认形式的方法实现帮助。 有关此技术的示例，请参阅第 104 页的 removeIf 方法。如果提供默认方法，请确保使用@implSpec Javadoc 标记（条目 19）将它们文档说明为继承。 使用默认方法可以提供实现帮助多多少少是有些限制的。 尽管许多接口指定了 Object 类中方法（如 equals 和 hashCode）的行为，但不允许为它们提供默认方法。 此外，接口不允许包含实例属性或非公共静态成员（私有静态方法除外）。 最后，不能将默认方法添加到不受控制的接口中。 但是，你可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。 按照惯例，骨架实现类被称为 AbstractInterface，其中 Interface 是它们实现的接口的名称。 例如，集合框架（ Collections Framework）提供了一个框架实现以配合每个主要集合接口：AbstractCollection，AbstractSet，AbstractList 和 AbstractMap。 可以说，将它们称为 SkeletalCollection，SkeletalSet，SkeletalList 和 SkeletalMap 是有道理的，但是现在已经确立了抽象约定。 如果设计得当，骨架实现（无论是单独的抽象类还是仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。 例如，下面是一个静态工厂方法，在 AbstractList 的顶层包含一个完整的功能齐全的 List 实现： 12345678910111213141516171819202122232425// Concrete implementation built atop skeletal implementationstatic List&lt;Integer&gt; intArrayAsList(int[] a) &#123; Objects.requireNonNull(a); // The diamond operator is only legal here in Java 9 and later // If you're using an earlier release, specify &lt;Integer&gt; return new AbstractList&lt;&gt;() &#123; @Override public Integer get(int i) &#123; return a[i]; // Autoboxing ([Item 6](https://www.safaribooksonline.com/library/view/effective-java-third/9780134686097/ch2.xhtml#lev6)) &#125; @Override public Integer set(int i, Integer val) &#123; int oldVal = a[I]; a[i] = val; // Auto-unboxing return oldVal; // Autoboxing &#125; @Override public int size() &#123; return a.length; &#125; &#125;;&#125; 当你考虑一个 List 实现为你做的所有事情时，这个例子是一个骨架实现的强大的演示。 顺便说一句，这个例子是一个适配器（Adapter）[Gamma95]，它允许一个 int 数组被看作 Integer 实例列表。 由于 int 值和整数实例（装箱和拆箱）之间的来回转换，其性能并不是非常好。 请注意，实现采用匿名类的形式（条目 24）。 骨架实现类的优点在于，它们提供抽象类的所有实现的帮助，而不会强加抽象类作为类型定义时的严格约束。对于具有骨架实现类的接口的大多数实现者来说，继承这个类是显而易见的选择，但它不是必需的。如果一个类不能继承骨架的实现，这个类可以直接实现接口。该类仍然受益于接口本身的任何默认方法。此外，骨架实现类仍然可以协助接口的实现。实现接口的类可以将接口方法的调用转发给继承骨架实现的私有内部类的包含实例。这种被称为模拟多重继承的技术与条目 18 讨论的包装类模式密切相关。它提供了多重继承的许多好处，同时避免了缺陷。 编写一个骨架的实现是一个相对简单的过程，虽然有些乏味。 首先，研究接口，并确定哪些方法是基本的，其他方法可以根据它们来实现。 这些基本方法是你的骨架实现类中的抽象方法。 接下来，为所有可以直接在基本方法之上实现的方法提供接口中的默认方法，回想一下，你可能不会为诸如 Object 类中 equals 和 hashCode 等方法提供默认方法。 如果基本方法和默认方法涵盖了接口，那么就完成了，并且不需要骨架实现类。 否则，编写一个声明实现接口的类，并实现所有剩下的接口方法。 为了适合于该任务，此类可能包含任何的非公共属性和方法。 作为一个简单的例子，考虑一下 Map.Entry 接口。 显而易见的基本方法是 getKey，getValue 和（可选的）setValue。 接口指定了 equals 和 hashCode 的行为，并且在基本方面方面有一个 toString 的明显的实现。 由于不允许为 Object 类方法提供默认实现，因此所有实现均放置在骨架实现类中： 12345678910111213141516171819202122232425262728293031323334// Skeletal implementation classpublic abstract class AbstractMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // Entries in a modifiable map must override this method @Override public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; // Implements the general contract of Map.Entry.equals @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry) o; return Objects.equals(e.getKey(), getKey()) &amp;&amp; Objects.equals(e.getValue(), getValue()); &#125; // Implements the general contract of Map.Entry.hashCode @Override public int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; @Override public String toString() &#123; return getKey() + \"=\" + getValue(); &#125;&#125; 请注意，这个骨架实现不能在 Map.Entry 接口中实现，也不能作为子接口实现，因为默认方法不允许重写诸如 equals，hashCode 和 toString 等 Object 类方法。 由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19 中的所有设计和文档说明。为了简洁起见，前面的例子中省略了文档注释，但是好的文档在骨架实现中是绝对必要的，无论它是否包含 一个接口或一个单独的抽象类的默认方法。 与骨架实现有稍许不同的是简单实现，以 AbstractMap.SimpleEntry 为例。 一个简单的实现就像一个骨架实现，它实现了一个接口，并且是为了继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。 你可以按照情况使用它，也可以根据情况进行子类化。 总而言之，一个接口通常是定义允许多个实现的类型的最佳方式。 如果你导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。 在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。 也就是说，对接口的限制通常要求骨架实现类采用抽象类的形式。","categories":[],"tags":[]},{"title":"高效java （十四） 如使用继承设计，应当文档说明","slug":"高效java-（十四）-如使用继承设计，应当文档说明","date":"2020-04-20T22:20:20.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/20/高效java-（十四）-如使用继承设计，应当文档说明/","link":"","permalink":"https://createralan.github.io/2020/04/20/高效java-（十四）-如使用继承设计，应当文档说明/","excerpt":"","text":"19. 如使用继承则设计，应当文档说明，否则不该使用 首先，这个类必须准确地描述重写这个方法带来的影响。 换句话说，该类必须文档说明可重写方法的自用性（self-use）。 对于每个公共或受保护的方法，文档必须指明方法调用哪些重写方法，以何种顺序以及每次调用的结果如何影响后续处理。 （重写方法，这里是指非 final 修饰的方法，无论是公开还是保护的。）更一般地说，一个类必须文档说明任何可能调用可重写方法的情况。 例如，后台线程或者静态初始化代码块可能会调用这样的方法。 调用可重写方法的方法在文档注释结束时包含对这些调用的描述。 这些描述在规范中特定部分，标记为“Implementation Requirements”，由 Javadoc 标签 @implSpec 生成。 本节介绍该方法的内部工作原理。 下面是从 java.util.AbstractCollection 类的规范中拷贝的例子： 从该集合中删除指定元素的单个实例（如果存在，optional 实例操作）。 更正式地说，如果这个集合包含一个或多个这样的元素，删除使得 Objects.equals(o, e) 的一个元素 e。 如果此集合包含指定的元素（或者等同于此集合因调用而发生了更改），则返回 true。 实现要求： 这个实现迭代遍历集合查找指定元素。 如果找到元素，则使用迭代器的 remove 方法从集合中删除元素。 请注意，如果此集合的 iterator 方法返回的迭代器未实现 remove 方法，并且此集合包含指定的对象，则此实现将引发 UnsupportedOperationException 异常。 这个文档毫无疑问地说明，重写 iterator 方法会影响 remove 方法的行为。 它还描述了 iterator 方法返回的 Iterator 行为将如何影响 remove 方法的行为。 与条目 18 中的情况相反，在这种情况下，程序员继承 HashSet 并不能说明重写 add 方法是否会影响 addAll 方法的行为。 但是，这是否违背了一个良好的 API 文档应该描述给定的方法是什么，而不是它是如何做的呢？ 是的，它确实！这是继承违反封装这一事实的不幸后果。要文档说明一个类以便可以安全地进行子类化，必须描述清楚那些没有详细说明的实现细节。 @implSpec 标签是在 Java 8 中添加的，并且在 Java 9 中被大量使用。这个标签应该默认启用，但是从 Java 9 开始，除非通过命令行开关-tag &quot;apiNote:a:API Note:&quot;，否则 Javadoc 实用工具仍然会忽略它。 设计继承涉及的不仅仅是文档说明自用的模式。 为了让程序员能够写出有效的子类而不会带来不适当的痛苦，一个类可能以明智选择的受保护方法的形式提供内部工作，或者在罕见的情况下，提供受保护的属性。 例如，考虑 java.util.AbstractList 中的 removeRange 方法： 从此列表中删除索引介于 fromIndex（包含）和 inclusive（不含）之间的所有元素。 将任何后续元素向左移（减少索引）。 这个调用通过（toIndex - fromIndex）元素来缩短列表。 （如果 toIndex == fromIndex，则此操作无效。） 这个方法是通过列表及其子类的 clear 操作来调用的。重写这个方法利用列表内部实现的优势，可以大大提高列表和子类的 clear 操作性能。 实现要求：这个实现获取一个列表迭代器，它位于 fromIndex 之前，并重复调用 ListIterator.remove 和 ListIterator.next 方法，直到整个范围被删除。 注意：如果 ListIterator.remove 需要线性时间，则此实现需要平方级时间。 参数： fromIndex 要移除的第一个元素的索引 toIndex 要移除的最后一个元素之后的索引 这个方法对 List 实现的最终用户来说是没有意义的。 它仅仅是为了使子类很容易提供一个快速 clear 方法。 在没有 removeRange 方法的情况下，当在子列表上调用 clear 方法，子类将不得不使用平方级的时间，否则，或从头重写整个 subList 机制——这不是一件容易的事情！ 那么当你设计一个继承类的时候，你如何决定暴露哪些的受保护的成员呢？ 不幸的是，没有灵丹妙药。 所能做的最好的就是努力思考，做出最好的测试，然后通过编写子类来进行测试。 应该尽可能少地暴露受保护的成员，因为每个成员都表示对实现细节的承诺。 另一方面，你不能暴露太少，因为失去了保护的成员会导致一个类几乎不能用于继承。 测试为继承而设计的类的唯一方法是编写子类。 如果你忽略了一个关键的受保护的成员，试图编写一个子类将会使得遗漏痛苦地变得明显。 相反，如果编写的几个子类，而且没有一个使用受保护的成员，那么应该将其设为私有。 经验表明，三个子类通常足以测试一个可继承的类。 这些子类应该由父类作者以外的人编写。 当你为继承设计一个可能被广泛使用的类的时候，要意识到你永远承诺你文档说明的自用模式以及隐含在其保护的方法和属性中的实现决定。 这些承诺可能会使后续版本中改善类的性能或功能变得困难或不可能。 因此， 在发布它之前，你必须通过编写子类来测试你的类。 另外，请注意，继承所需的特殊文档混乱了正常的文档，这是为创建类的实例并在其上调用方法的程序员设计的。 在撰写本文时，几乎没有工具将普通的 API 文档从和仅仅针对子类实现的信息，分离出来。 还有一些类必须遵守允许继承的限制。 构造方法绝不能直接或间接调用可重写的方法。 如果违反这个规则，将导致程序失败。 父类构造方法在子类构造方法之前运行，所以在子类构造方法运行之前，子类中的重写方法被调用。 如果重写方法依赖于子类构造方法执行的任何初始化，则此方法将不会按预期运行。 为了具体说明，这是一个违反这个规则的类： 12345678public class Super &#123; // Broken - constructor invokes an overridable method public Super() &#123; overrideMe(); &#125; public void overrideMe() &#123; &#125;&#125; 以下是一个重写 overrideMe 方法的子类，Super 类的唯一构造方法会错误地调用它： 12345678910111213141516171819public final class Sub extends Super &#123; // Blank final, set by constructor private final Instant instant; Sub() &#123; instant = Instant.now(); &#125; // Overriding method invoked by superclass constructor @Override public void overrideMe() &#123; System.out.println(instant); &#125; public static void main(String[] args) &#123; Sub sub = new Sub(); sub.overrideMe(); &#125;&#125; 你可能期望这个程序打印两次 instant 实例，但是它第一次打印出 null，因为在 Sub 构造方法有机会初始化 instant 属性之前，overrideMe 被 Super 构造方法调用。 请注意，这个程序观察两个不同状态的 final 属性！ 还要注意的是，如果 overrideMe 方法调用了 instant 实例中任何方法，那么当父类构造方法调用 overrideMe 时，它将抛出一个 NullPointerException 异常。 这个程序不会抛出 NullPointerException 的唯一原因是 println 方法容忍 null 参数。 请注意，从构造方法中调用私有方法，其中任何一个方法都不可重写的，那么 final 方法和静态方法是安全的。 Cloneable 和 Serializable 接口在设计继承时会带来特殊的困难。 对于为继承而设计的类来说，实现这些接口通常不是一个好主意，因为这会给继承类的程序员带来很大的负担。 然而，可以采取特殊的行动来允许子类实现这些接口，而不需要强制这样做。 如果你决定在为继承而设计的类中实现 Cloneable 或 Serializable 接口，那么应该知道，由于 clone 和 readObject 方法与构造方法相似，所以也有类似的限制： clone 和 readObject 都不会直接或间接调用可重写的方法。 在 readObject 的情况下，重写方法将在子类的状态被反序列化之前运行。 在 clone 的情况下，重写方法将在子类的 clone 方法有机会修复克隆的状态之前运行。 在任何一种情况下，都可能会出现程序故障。 在 clone 的情况下，故障可能会损坏原始对象以及被克隆对象本身。 例如，如果重写方法假定它正在修改对象的深层结构的拷贝，但是尚未创建拷贝，则可能发生这种情况。 最后，如果你决定在为继承设计的类中实现 Serializable 接口，并且该类有一个 readResolve 或 writeReplace 方法，则必须使 readResolve 或 writeReplace 方法设置为受保护而不是私有。 如果这些方法是私有的，它们将被子类无声地忽略。 这是另一种情况，把实现细节成为类的 API 的一部分，以允许继承。 到目前为止，设计一个继承类需要很大的努力，并且对这个类有很大的限制。 这不是一个轻率的决定。 有些情况显然是正确的，比如抽象类，包括接口的骨架实现（skeletal implementations）（条目 20）。 还有其他的情况显然是错误的，比如不可变的类。 但是普通的具体类呢？ 传统上，它们既不是 final 的，也不是为了子类化而设计和文档说明的，但是这种情况是危险的。每次修改这样的类，则继承此类的子类将被破坏。 这不仅仅是一个理论问题。 在修改非 final 的具体类的内部之后，接收与子类相关的错误报告并不少见，这些类没有为继承而设计和文档说明。 解决这个问题的最好办法是，在没有想要安全地子类化的设计和文档说明的类中禁止子类化。 有两种方法禁止子类化。 两者中较容易的是声明类为 final。 另一种方法是使所有的构造方法都是私有的或包级私有的，并且添加公共静态工厂来代替构造方法。 这个方案在内部提供了使用子类的灵活性，在条目 17 中讨论过。两种方法都是可以接受的。 这个建议可能有些争议，因为许多程序员已经习惯于继承普通的具体类来增加功能，例如通知和同步等功能，或限制原有类的功能。 如果一个类实现了捕获其本质的一些接口，比如 Set，List 或 Map，那么不应该为了禁止子类化而感到愧疚。 在条目 18 中描述的包装类模式为增强功能提供了继承的优越选择。 如果一个具体的类没有实现一个标准的接口，那么你可能会通过禁止继承来给一些程序员带来不便。 如果你觉得你必须允许从这样的类继承，一个合理的方法是确保类从不调用任何可重写的方法，并文档说明这个事实。 换句话说，完全消除类的自用（self-use）的可重写的方法。 这样做，你将创建一个合理安全的子类。 重写一个方法不会影响任何其他方法的行为。 你可以机械地消除类的自我使用的重写方法，而不会改变其行为。 将每个可重写的方法的主体移动到一个私有的“帮助器方法”，并让每个可重写的方法调用其私有的帮助器方法。 然后用直接调用可重写方法的专用帮助器方法来替换每个自用的可重写方法。 总之，设计一个继承类是一件很辛苦的事情。 你必须文档说明所有的自用模式，一旦你文档说明了它们，必须承诺为他们的整个生命周期。 如果你不这样做，子类可能会依赖于父类的实现细节，并且如果父类的实现发生改变，子类可能会损坏。 为了允许其他人编写高效的子类，可能还需要导出一个或多个受保护的方法。 除非你知道有一个真正的子类需要，否则你可能最好是通过声明你的类为 final 禁止继承，或者确保没有可访问的构造方法。","categories":[],"tags":[]},{"title":"高效java （十三） 优选选择对象组合而不是继承","slug":"高效java-（十三）-优选选择对象组合而不是继承","date":"2020-04-19T17:27:18.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/19/高效java-（十三）-优选选择对象组合而不是继承/","link":"","permalink":"https://createralan.github.io/2020/04/19/高效java-（十三）-优选选择对象组合而不是继承/","excerpt":"","text":"使用继承实现代码复用很强大的方法。 在同一个包中由程序员控制子类和超类也是安全的，但是对于普通的具体类进行跨包边界的继承是危险的。 （本文暂不讨论接口继承） 继承-破坏了封装子类的功能正常与否依赖于它的超类的实现细节。超类的实现可能在版本之间发生变化，如果发生了变化，子类可能会崩溃，即使子类的代码没有被修改过。子类必须与其超类同步发展，除非超类是专门为扩展所设计的。 我们以HashSet举一个例子 继承HashSet 且覆盖add ，addAll两个方法，getAddCount返回Set中的个数 1234567891011121314151617181920212223242526272829// Broken - Inappropriate use of inheritance!public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123; // The number of attempted element insertions private int addCount = 0; public InstrumentedHashSet() &#123; &#125; public InstrumentedHashSet(int initCap, float loadFactor) &#123; super(initCap, loadFactor); &#125; @Override public boolean add(E e) &#123; addCount++; return super.add(e); &#125; @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123; addCount += c.size(); return super.addAll(c); &#125; public int getAddCount() &#123; return addCount; &#125;&#125; 123InstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();s.addAll(Arrays.asList(\"Snap\", \"Crackle\", \"Pop\"));System.out.println(s.getAddCount()); 我们希望此处getAddCount（）返回的是3 ，但会返回6 ，到底是哪里出错了？ 在内部，HashSet 的 addAll 方法是在其 add 方法之上实现的，尽管 HashSet 相当合理地没有记录这个实现细节。InstrumentedHashSet 中的 addAll 方法向 addCount 添加了三个元素，然后使用 super.addAll 调用 HashSet 的 addAll 实现。这反过来调用 add 方法（在 InstrumentedHashSet 中被覆盖），每个元素一次。这三个调用中的每一个都向 addCount 添加了一个元素，总共增加了 6 个元素：使用 addAll 方法添加的每个元素都被重复计数。 我们可以通过消除 addAll 方法的覆盖来「修复」子类。虽然生成的类可以工作，但它的正确功能取决于 HashSet 的 addAll 方法是在 add 方法之上实现的事实。这种「自用」是实现细节，不能保证在 Java 平台的所有实现中都存在，也不能保证在版本之间进行更改。因此，结果得到的 InstrumentedHashSet 类是脆弱的。 覆盖 addAll 方法以遍历指定的集合稍微好一些，为每个元素调用一次 add 方法。无论 HashSet 的 addAll 方法是否在其 add 方法之上实现，这都将保证正确的结果，因为 HashSet 的 addAll 实现将不再被调用。然而，这种技术并不能解决我们所有的问题。它相当于重新实现超类方法，这可能会导致「自用」，也可能不会，这是困难的、耗时的、容易出错的，并且可能会降低性能。此外，这并不总是可能的，因为如果不访问子类无法访问的私有字段，就无法实现某些方法。 还好我们有一个方法可以避免以上问题! 对象组合有时也成为复合、聚合、包容等 组合是一种通过创建一个组合了其他的对象，从而获得新功能的复用方法 将功能委托给所组合的一个对象，从而获得新功能 优点 容器类仅能通过被包含对象的接口来对其进行访问 黑盒复用，因为被包含对象的内部细节对外是不可见的 实现上的相互依赖性比较小 每一个类只专注于一项任务 通过获取指向其他的具有相同类型的对象引用，可以在运行期间动态地定义组合 缺点 导致系统中的对象过多 为了能将多个不同的对象作为组合块（composition block）来使用，必须仔细地对接口进行定义。 现有的类是新类的一个组件。新类中的每个实例方法调用现有类的包含实例上的对应方法，并返回结果。这称为转发，新类中的方法称为转发方法。生成的类将非常坚固，不依赖于现有类的实现细节。即使向现有类添加新方法，也不会对新类产生影响。为了使其具体化，这里有一个使用复合和转发方法的方法，用以替代 InstrumentedHashSet。注意，实现被分成两部分，类本身和一个可复用的转发类，其中包含所有的转发方法，没有其他内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Wrapper class - uses composition in place of inheritancepublic class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; &#123; private int addCount = 0; public InstrumentedSet(Set&lt;E&gt; s) &#123; super(s); &#125; @Override public boolean add(E e) &#123; addCount++; return super.add(e); &#125; @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123; addCount += c.size(); return super.addAll(c); &#125; public int getAddCount() &#123; return addCount; &#125;&#125;// Reusable forwarding classpublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; &#123; private final Set&lt;E&gt; s; public ForwardingSet(Set&lt;E&gt; s) &#123; this.s = s; &#125; public void clear() &#123; s.clear(); &#125; public boolean contains(Object o) &#123; return s.contains(o); &#125; public boolean isEmpty() &#123; return s.isEmpty(); &#125; public int size() &#123; return s.size(); &#125; public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125; public boolean add(E e) &#123; return s.add(e); &#125; public boolean remove(Object o) &#123; return s.remove(o); &#125; public boolean containsAll(Collection&lt;?&gt; c) &#123; return s.containsAll(c); &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return s.addAll(c); &#125; public boolean removeAll(Collection&lt;?&gt; c) &#123; return s.removeAll(c); &#125; public boolean retainAll(Collection&lt;?&gt; c) &#123; return s.retainAll(c); &#125; public Object[] toArray() &#123; return s.toArray(); &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125; @Override public boolean equals(Object o)&#123; return s.equals(o); &#125; @Override public int hashCode() &#123; return s.hashCode(); &#125; @Override public String toString() &#123; return s.toString(); &#125;&#125; InstrumentedSet 类的设计是通过 Set 接口来实现的，这个接口可以捕获 HashSet 类的功能。除了健壮外，这个设计非常灵活。InstrumentedSet 类实现了 Set 接口，有一个构造函数，它的参数也是 Set 类型的。实际上，这个类可以将任何一个 Set 转换成另一个 Set，并添加 instrumentation 的功能。基于继承的方法只适用于单个具体类，并且需要为超类中每个受支持的构造函数提供单独的构造函数，与此不同的是，包装器类可用于仪器任何集合实现，并将与任何现有构造函数一起工作： 12Set&lt;Instant&gt; times = new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp));Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new HashSet&lt;&gt;(INIT_CAPACITY)); InstrumentedSet 类甚至还可以用来临时配置一个没有 instrumentation 功能的 Set 实例： 1234static void walk(Set&lt;Dog&gt; dogs) &#123;InstrumentedSet&lt;Dog&gt; iDogs = new InstrumentedSet&lt;&gt;(dogs);... // Within this method use iDogs instead of dogs&#125; InstrumentedSet 类被称为包装类，因为每个 InstrumentedSet 实例都包含(「包装」)另一个集合实例。这也称为装饰者模式 [Gamma95]，因为 InstrumentedSet 类通过添加插装来「装饰」一个集合。有时复合和转发的组合被不当地称为委托。严格来说，除非包装器对象将自身传递给包装对象，否则它不是委托 包装类的缺点很少。一个需要注意的点是：包装类不适合在回调框架中使用，在回调框架中，对象为后续调用(「回调」)将自定义传递给其他对象。因为包装对象不知道它的包装器，所以它传递一个对它自己的引用（this），回调避开包装器。这就是所谓的「自用」问题。有些人担心转发方法调用的性能影响或包装器对象的内存占用影响。这两种方法在实践中都没有多大影响。编写转发方法很麻烦，但是你必须只为每个接口编写一次可复用的转发类，而且可能会为你提供转发类。例如，Guava 为所有的集合接口提供了转发类 Coad规则仅当下列的所有标准被满足时，方可使用继承： a.子类表达了”是一个…的特殊类型”，而非”是一个由…所扮演的角色”。 b子类的一个实例永远不需要转化（transmute）为其它类的一个对象。 c.子类是对其父类的职责（responsibility）进行扩展，而非重写或废除（nullify）。 d.子类没有对那些仅作为一个工具类（utility class）的功能进行扩展。 e.对于一个位于实际的问题域（Problem Domain）的类而言，其子类特指一种角色（role），交易（transaction）或设备（device）。 继承/组合总结1.组合与继承都是重要的重用方法 2.在OO开发的早期，继承被过度地使用 3.随着时间的发展，我们发现优先使用组合可以获得重用性与简单性更佳的设计 4.当然可以通过继承，以扩充（enlarge）可用的组合类集（the set of composable classes）。 5.因此组合与继承可以一起工作 6.但是我们的基本法则是： 优先使用对象组合，而非（类）继承","categories":[],"tags":[]},{"title":"linux命令行 （二） 运行脚本","slug":"linux命令行-（二）-运行脚本","date":"2020-04-18T23:18:44.000Z","updated":"2020-11-25T02:51:30.645Z","comments":true,"path":"2020/04/18/linux命令行-（二）-运行脚本/","link":"","permalink":"https://createralan.github.io/2020/04/18/linux命令行-（二）-运行脚本/","excerpt":"","text":"首先上例子： ####查看文件内容 1% cat my_echo.py 123456789import sysdef main(): print(' '.join(sys.argv[1:]))if __name___ == '__main__': main() ####执行文件 ： 解释器 脚本文件 【参数】 12% python3 my_echo.py hello worldhello world ####在文件内添加解释器 把这个加在需执行文件的上面来制定解释器 必须放在第一行 #! ，并使用绝对路径，但如果使用/usr/bin/env ，系统会自动帮你运行环境变量中的解释器等价于写绝对路径 1% #!/usr/bin/env python3 ####增加可执行权限 （change mode） +x 是可执行权限 -x 也可以减 还有一种是数字 Owner 7 = 1+2+4 = 可执行 + 可写 + 可读（妙啊！） 1% chomd +x my_echo.py ####运行脚本（在添加解释器之后）% 12% ./my_echo.py hello world!hello world ####更改文件名（移动文件） 1% mv my_echo.py myecho cp 复制文件 （cp -r 复制文件夹） rm 删除文件（ rm -rf 强制递归删除一切 ） ####将当前路径追加到环境变量 （不是永久的） 1% PATH= $PATH:$PWD ####上#一步骤将当前路径添加到环境变量后，在任意路径可以执行该python脚本 12% my_echo hello world!hello world! ####查看该可执行文件所配置的环境变量位置 12% which my_echo/Users/xiapazi/cmd2/my_echo 娱乐时间-未成年人请勿模仿 一直输出 ： AMD YES！ 12345678910111213% yesyyyyyyyyyyy... 123456789101112% yes AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !AMD YES !... 下面恐怖的开始了！！！ 1234567% yes &apos;AMD YES&apos; &gt; amd.txt （无限输入&apos;AMD YES&apos;到amd.txt文件中）（10s左右的等待时间）（CTRL+C 停止）% cat amd.txt | wc -l (查看一共有多少行)129470008 （超过一亿行了）% ls -lh(显示amd.txt已经超过了1个g) 每秒写100m ，超快~~~ bye bye 我们还有下期命令行！","categories":[],"tags":[]},{"title":"","slug":"高效java-（十二）-减少类的可变性","date":"2020-04-18T00:00:00.000Z","updated":"2020-11-25T02:51:30.645Z","comments":true,"path":"2020/04/18/高效java-（十二）-减少类的可变性/","link":"","permalink":"https://createralan.github.io/2020/04/18/高效java-（十二）-减少类的可变性/","excerpt":"","text":"title:高效java （十二） 减少类的可变性date:2020-04-18 22:13:15tags:java categories:[java]An immutable class is simply a class whole instances cannot be modified . All of the information contained in each instance is fixed for the lifetime of the object , so no changes can ever be observed . The java platform libraies contain many immutable classes , including String ,the boxed primitive classes , and BigInteger and BigDecimal . There are many good reasons for this： Immutable classes are easier to design , implement ,and use than mutable classes , They are less prone to error and are more secure. 不可变类就是一个实例不能被修改的类。每个实例中包含的所有信息在对象的声明周期内都是固定的，因此永远不会观察到任何更改。Java库包含许多不可变的类，包括String、基本类型的包装类、BigInteger 和 BigDecimal。这么做有很好的理由：不可变类比可变类更容易设计、实现和使用。他们不太容易出错、而且更安全。 ###实现不可变类，请遵循5条规则 不要提供修改对象状态的方法。 确保类不能被扩展 这可以防止无意或恶意的自雷以其对象状态可改变的方式，而损害超类的不可变行为。 所有字段用final修饰 所有字段为私有 确保对任何可变组件的独占访问 如果你的类有任何引用可变对象的字段，请确保该类的客户端无法获得这些对象的引用。永远不要想提供对象引用的客户端初始化这样的字段，也不要从访问器返回字段。 下面是 一个比较复杂的例子1234567891011121314151617181920212223242526272829303132333435363738394041424344// Immutable complex number classpublic final class Complex &#123; private final double re; private final double im; public Complex(double re, double im) &#123; this.re = re; this.im = im; &#125; public double realPart() &#123; return re; &#125; public double imaginaryPart() &#123; return im; &#125; public Complex plus(Complex c) &#123; return new Complex(re + c.re, im + c.im); &#125; public Complex minus(Complex c) &#123; return new Complex(re - c.re, im - c.im); &#125; public Complex times(Complex c) &#123; return new Complex(re * c.re - im * c.im, re * c.im + im * c.re); &#125; public Complex dividedBy(Complex c) &#123; double tmp = c.re * c.re + c.im * c.im; return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp); &#125; @Override public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Complex)) return false; Complex c = (Complex) o; // See page 47 to find out why we use compare instead of == return Double.compare(c.re, re) == 0 &amp;&amp; Double.compare(c.im, im) == 0; &#125; @Override public int hashCode() &#123; return 31 * Double.hashCode(re) + Double.hashCode(im); &#125; @Override public String toString() &#123; return \"(\" + re + \" + \" + im + \"i)\"; &#125;&#125; 这个类表示一个复数，除了标准的Obejct方法之外，他还为实部和虚部提供访问器，并提供加减乘除。需要注意的是，算术操作如何创建和返回一个新的Complex实例，而不是修改这个实例。这种模式成为泛函方法。因为方法返回对其操作数应用函数为结果，而不是修改它。将其与方法将过程应用于其操作数的过程或命令方式进行对比，使其状态发生变化。注意，方法名是介词（PLUS），而不是动词(ADD)，这无形中就可以看出方法不会改变对象的值。BigInteger 和 BigDecimal类不遵守这个命名约定，导致了许多使用错误。 优缺点一个不可变的对象可以七号处于一种状态，即使创建的状态。如果你确保所有构造函数都建立了类不变量，那么就可以保证这些不变量将一直保持，而你和使用该类的程序员无需再做任何事。 你不仅可以共享不可变对象，而且可以共享它们的内部实现。 例如，BigInteger类在内部使用符号大小来表示。符号由int表示，大小由int数组表示。negate方法产生一个新的BigInteger，大小相同，符号相反。即使数组是可变的，也不需要复制；新创建的BigInteger指向与原始数组相同的内部数组。 不可变对象可以很好的作为其他对象的构建模块 无论是可变的还是不可变的。如果知道复杂对象的组件对象不会在其内部发生更改，那么维护复杂对象的不变性就会容易得多。这个原则的一个具体的例子是，不可变对象很合适 Map 的键和 Set 的元素：你不必担心它们的值在 Map 或 Set 中发生变化，否则会破坏 Map 或 Set 的不变性。 不可变对象自带提供故障原子性 他们的状态从未改变，所以不可能出现暂时的不一致。 不可变类的主要缺点是每个不同的值都需要一个单独的对象。 创建这些对象的成本可能很高，尤其是如果对象很大的话。","categories":[],"tags":[]},{"title":"高效java （十一） 在公共类中使用访问方法而不是公共属性 ","slug":"高效java-（十一）-在公共类中使用访问方法而不是公共属性","date":"2020-04-17T14:55:18.000Z","updated":"2020-11-25T02:51:30.645Z","comments":true,"path":"2020/04/17/高效java-（十一）-在公共类中使用访问方法而不是公共属性/","link":"","permalink":"https://createralan.github.io/2020/04/17/高效java-（十一）-在公共类中使用访问方法而不是公共属性/","excerpt":"","text":"你有没有想过，我为啥要写一个对象实体类，把属性设置为public，就不用再写get、set了！ 像这样 12345// Degenerate classes like this should not be public!class Point &#123; public double x; public double y;&#125; 简单！ 如果一个类在其包之外是可访问的，则提供访问方法来保留更改类内部表示的灵活性。 如果一个类暴露其数据属性，那么以后更改其表示形式基本上是没有可能，因为客户端代码可以散布在很多地方！！！ 如果一个类是包级私有级别的，或者是一个私有类的内部，那么暴露它的数据属性就没有什么本质上的错误–假设它们提供足够描述该类提供的对象。 在类定义和使用它的客户端代码中，这种方法比访问方法产生更少的视觉混乱。 虽然客户端代码绑定到类的内部表示，但是这些代码仅限于包含该类的包。 如果类的内部表示是可取的，可以在不触碰包外的任何代码的情况下进行更改。 在私有内部类的情况下，更改作用范围进一步限制在封闭类中。Java 平台类库中的几个类违反了公共类不应直接暴露属性的建议。 著名的例子包括 java.awt 包中的 Point 和 Dimension 类。 这些类别应该被视为警示性的示例，而不是模仿的例子。 如条目 67 所述，时至今日，暴露 Dimension 的内部结构的决定仍然导致着严重的性能问题。 总结总之，公共类不应该暴露可变属性。 公共类暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有内部类来暴露属性，无论此类是否是可变的。","categories":[],"tags":[]},{"title":"高效java （十）使类和成员的可访问性最小化 ","slug":"高效java-（十）使类和成员的可访问性最小化","date":"2020-04-16T14:54:59.000Z","updated":"2020-11-25T02:51:30.645Z","comments":true,"path":"2020/04/16/高效java-（十）使类和成员的可访问性最小化/","link":"","permalink":"https://createralan.github.io/2020/04/16/高效java-（十）使类和成员的可访问性最小化/","excerpt":"","text":"让每个类或成员尽可能地不可访问好组件和差组件的最大区别因素：隐藏内部数据和其他实现细节的程度。 一个设计良好的组件隐藏了它的所有实现细节，干净地将它的 API 与它的实现分离开来。然后，组件只通过它们的 API 进行通信，并且对彼此的内部工作一无所知。这一概念，被称为信息隐藏或封装，是软件设计的基本原则 Java中对于成员（字段、方法、嵌套类、嵌套接口），有四种可能的访问级别： private 该成员只能在声明它的顶级类内访问 package-private （默认访问级别，接口除外）成员可以从被声明的包中的任何类中访问 protected 成员可以从被申明的类的子类中访问 public 该成员可以从任何地方被访问 下面是一些在实现类时的一些tip 公共类的实例字段很少情况下采用public 修饰，带有公共可变字段的类通常是不安全的 非零长度的数组总是可变的，类具有公共静态final数组字段，或返回一个这样的字符使是错误的 12// Potential security hole!public static final Thing[] VALUES = &#123; ... &#125;; 解决办法： 12private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final List&lt;Thing&gt; VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES)); 或者 12345private static final Thing[] PRIVATE_VALUES = &#123; ... &#125;;public static final Thing[] values() &#123; return PRIVATE_VALUES.clone();&#125; ##总结： 总而言之，应该尽可能地减少程序元素的可访问性（在合理范围内）。 在仔细设计一个最小化的公共 API 之后，你应该防止任何散乱的类，接口或成员成为 API 的一部分。 除了作为常量的公共静态 final 字段之外，公共类不应该有公共字段。 确保 public static final 字段引用的对象是不可变的。","categories":[],"tags":[]},{"title":"高效java （九） 考虑实现Compable接口","slug":"高效java-（九）-考虑实现Compable接口","date":"2020-04-15T21:34:15.000Z","updated":"2020-11-25T02:51:30.645Z","comments":true,"path":"2020/04/15/高效java-（九）-考虑实现Compable接口/","link":"","permalink":"https://createralan.github.io/2020/04/15/高效java-（九）-考虑实现Compable接口/","excerpt":"","text":"CompareTo方法并没有在Obejct类中声明。 它是Comparable接口中唯一的方法。 它与Object类的equals方法在性质上是相似的，除了它允许在简单的相等比较之外的顺序比较，它是泛型的。通过实现Comparable接口，一个类表明它的实例有一个自然顺序。对实现Comparable接口的对象数组排序非常简单。 1Arrays.sort(a) CompareTo方法的通用约定： 将此对象与指定的对象按照排序进行比较。 返回值可能为负整数，零或正整数，因为此对象对应小于，等于或大于指定的对象。 如果指定对象的类型与此对象不能进行比较，则引发 ClassCastException 异常。 下面的描述中，符号 sgn(expression) 表示数学中的 signum 函数，它根据表达式的值为负数、零、正数，对应返回-1、0 和 1。 实现类必须确保所有 x 和 y 都满足 sgn(x.compareTo(y)) == -sgn(y. compareTo(x))。 （这意味着当且仅当 y.compareTo(x) 抛出异常时，x.compareTo(y) 必须抛出异常。） 实现类还必须确保该关系是可传递的：(x. compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) 意味着 x.compareTo(z) &gt; 0。 最后，对于所有的 z，实现类必须确保 x.compareTo(y) == 0 意味着 sgn(x.compareTo(z)) == sgn(y.compareTo(z))。 强烈推荐 (x.compareTo(y) == 0) == (x.equals(y))，但不是必需的。 一般来说，任何实现了 Comparable 接口的类违反了这个条件都应该清楚地说明这个事实。 推荐的语言是「注意：这个类有一个自然顺序，与 equals 不一致」。 在 Java 8 中 Comparator 接口提供了一系列比较器方法，可以使比较器流畅地构建。 这些比较器可以用来实现 compareTo 方法，就像 Comparable 接口所要求的那样。 许多程序员更喜欢这种方法的简洁性，尽管它的性能并不出众：在我的机器上排序 PhoneNumber 实例的数组速度慢了大约 10％。 在使用这种方法时，考虑使用 Java 的静态导入，以便可以通过其简单名称来引用比较器静态方法，以使其清晰简洁。 以下是 PhoneNumber 的 compareTo 方法的使用方法： 123456789// Comparable with comparator construction methodsprivate static final Comparator&lt;PhoneNumber&gt; COMPARATOR = comparingInt((PhoneNumber pn) -&gt; pn.areaCode) .thenComparingInt(pn -&gt; pn.prefix) .thenComparingInt(pn -&gt; pn.lineNum);public int compareTo(PhoneNumber pn) &#123; return COMPARATOR.compare(this, pn);&#125;复制ErrorOK! 此实现在类初始化时构建比较器，使用两个比较器构建方法。第一个是 comparingInt 方法。它是一个静态方法，它使用一个键提取器函数式接口（key extractor function）作为参数，将对象引用映射为 int 类型的键，并返回一个根据该键排序的实例的比较器。在前面的示例中，comparingInt 方法使用 lambda 表达式，它从 PhoneNumber 中提取区域代码，并返回一个 Comparator，根据它们的区域代码来排序电话号码。注意，lambda 表达式显式指定了其输入参数的类型 (PhoneNumber pn)。事实证明，在这种情况下，Java 的类型推断功能不够强大，无法自行判断类型，因此我们不得不帮助它以使程序编译。 如果两个电话号码实例具有相同的区号，则需要进一步细化比较，这正是第二个比较器构建方法，即 thenComparingInt 方法做的。 它是 Comparator 上的一个实例方法，接受一个 int 类型键提取器函数式接口（key extractor function）作为参数，并返回一个比较器，该比较器首先应用原始比较器，然后使用提取的键来打破连接。 你可以按照喜欢的方式多次调用 thenComparingInt 方法，从而产生一个字典顺序。 在上面的例子中，我们将两个调用叠加到 thenComparingInt，产生一个排序，它的二级键是 prefix，而其三级键是 lineNum。 请注意，我们不必指定传递给 thenComparingInt 的任何一个调用的键提取器函数式接口的参数类型：Java 的类型推断足够聪明，可以自己推断出参数的类型。 Comparator 类具有完整的构建方法。对于 long 和 double 基本类型，也有对应的类似于 comparingInt 和 thenComparingInt 的方法，int 版本的方法也可以应用于取值范围小于 int 的类型上，如 short 类型，如 PhoneNumber 实例中所示。对于 double 版本的方法也可以用在 float 类型上。这提供了所有 Java 的基本数字类型的覆盖。 也有对象引用类型的比较器构建方法。静态方法 comparing 有两个重载方式。第一个方法使用键提取器函数式接口并按键的自然顺序。第二种方法是键提取器函数式接口和比较器，用于键的排序。thenComparing 方法有三种重载。第一个重载只需要一个比较器，并使用它来提供一个二级排序。第二次重载只需要一个键提取器函数式接口，并使用键的自然顺序作为二级排序。最后的重载方法同时使用一个键提取器函数式接口和一个比较器来用在提取的键上。 有时，你可能会看到 compareTo 或 compare 方法依赖于两个值之间的差值，如果第一个值小于第二个值，则为负；如果两个值相等则为零，如果第一个值大于，则为正值。这是一个例子： 1234567// BROKEN difference-based comparator - violates transitivity!static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123; public int compare(Object o1, Object o2) &#123; return o1.hashCode() - o2.hashCode(); &#125;&#125;;复制ErrorOK! 不要使用这种技术！它可能会导致整数最大长度溢出和 IEEE 754 浮点运算失真的危险[JLS 15.20.1,15.21.1]。 此外，由此产生的方法不可能比使用上述技术编写的方法快得多。 使用静态 compare 方法： 123456// Comparator based on static compare methodstatic Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() &#123; public int compare(Object o1, Object o2) &#123; return Integer.compare(o1.hashCode(), o2.hashCode()); &#125;&#125;;复制ErrorOK! 或者使用 Comparator 的构建方法： 123// Comparator based on Comparator construction methodstatic Comparator&lt;Object&gt; hashCodeOrder = Comparator.comparingInt(o -&gt; o.hashCode());复制ErrorOK! 总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现 Comparable 接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较 compareTo 方法的实现中的字段值时，请避免使用「&lt;」和「&gt;」运算符。 相反，使用包装类中的静态 compare 方法或 Comparator 接口中的构建方法。","categories":[],"tags":[]},{"title":"高效java （八）谨慎地重写clone方法","slug":"高效java-（八）谨慎地重写clone方法","date":"2020-04-14T14:47:09.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/14/高效java-（八）谨慎地重写clone方法/","link":"","permalink":"https://createralan.github.io/2020/04/14/高效java-（八）谨慎地重写clone方法/","excerpt":"","text":"Cloneable接口不包含任何方法。 你可能想说 WTF！那它用来做什么？ ​ 它决定了Obejct的受保护的clone方法实现的行为：如果一个类实现了Cloneable接口，那么Object的clone方法将返回该对象的逐个属性拷贝；否则会抛出CloneNotSupportedException异常。这是一个非常反常的接口使用，不应该被效仿。通常情况下，实现一个接口用来表示可以为客户做什么。但是对于Cloneable接口，它会修改父类上受保护的方法的行为。 ​ 虽然规范并没有说明，但是在实践中，实现Cloneable接口的类希望提供一个正常的公共clone方法。为了实现这一目标，该类以及所有父类必须遵循一个复杂的，不可执行的，稀疏的文档协议。由此产生的机制是脆弱的、危险的和不受语言影响的：它创建对象而不需要调用构造方法。 以下是从Object规范中截取的部分： 对于任何对象，x.clone() != x == true x.clone().getClass() = x.getClass() == true x.clone().equals(x) == true 以上要求为通常情况下的，并不是绝对的 ​ 假如你希望在一个类中实现Cloneable接口，它的父类提供了一个行为料号的clone方法。首先调用super.clone。得到的对象僵尸院士的完全功能的复制品。在你的类中声明的任何属性将具有与原始属性相同的值。如果每个属性包含原始值或对不可变对象的引用，则返回的对象可能正是你所需要的，在这种情况下，不需要进一步处理。但请注意，不可变类永远不应该提供clone方法，因为只实惠浪费复制。 12345678// Clone method for class with no references to mutable state@Override public PhoneNumber clone() &#123; try &#123; return (PhoneNumber) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new AssertionError(); // Can't happen &#125;&#125; ​ 为了使这个方法起作用，PhoneNumber 的类声明必须被修改，以表明它实现了 Cloneable 接口。 虽然 Object 类的 clone 方法返回 Object 类，但是这个 clone 方法返回 PhoneNumber 类。 这样做是合法和可取的，因为 Java 支持协变返回类型。 换句话说，重写方法的返回类型可以是重写方法的返回类型的子类。 这消除了在客户端转换的需要。 在返回之前，我们必须将 Object 的 super.clone 的结果强制转换为 PhoneNumber，但保证强制转换成功。 super.clone 的调用包含在一个 try-catch 块中。 这是因为 Object 声明了它的 clone 方法来抛出 CloneNotSupportedException 异常，这是一个检查时异常。 由于 PhoneNumber 实现了 Cloneable 接口，所以我们知道调用 super.clone 会成功。 这里引用的需要表明 CloneNotSupportedException 应该是未被检查的 考虑到与 Cloneable 接口相关的所有问题，新的接口不应该继承它，新的可扩展类不应该实现它。 虽然实现 Cloneable 接口对于 final 类没有什么危害，但应该将其视为性能优化的角度，仅在极少数情况下才是合理的。 通常，复制功能最好由构造方法或工厂提供。 这个规则的一个明显的例外是数组，它最好用 clone 方法复制。","categories":[],"tags":[]},{"title":"高效java （七） 重写 equals 方法","slug":"高效java-（七）-重写-equals-方法时遵守通用约定","date":"2020-04-12T11:24:02.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/12/高效java-（七）-重写-equals-方法时遵守通用约定/","link":"","permalink":"https://createralan.github.io/2020/04/12/高效java-（七）-重写-equals-方法时遵守通用约定/","excerpt":"","text":"虽说Obejct类是一个具体的类，但它主要是为了继承而设计的。 它的所有非final方法都有清晰的约定，如果你不这么做，将会阻止其他依赖于约定的类，与此类一起工作。 什么情况下需要重写equals方法呢？ 例：当你需要一个逻辑相等的概念，例如Integer或者String，程序员使用equals方法比较值对象的引用，期望发现它们在逻辑上相等。 当你重写equals方法，Object的规范如下： 自反性：对于任何非空引用 x，x.equals(x) 必须返回true 对称性：对于任何非空引用x、y，如果且仅当 y.equals(x)返回true时，x.equals(y)必须返回true 传递性：对于任何非空引用x、y、z，如果x.equals(y)返回true，y.equals(z) 返回true，则x.equals(z)必须返回true 一致性：对于任何非空引用x、y，如果在equals比较中使用的信息没有修改，则x.equals(y)的多次调用必须返回true 非空性（这个名字不是官方定义的）：对于任何非空引用，x.equals(null)必须返回false 编写和测试 equals（和 hashCode）方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌 AutoValue 开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue 框架生成的方法与你自己编写的方法本质上是相同的。 很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成 equals 和 hashCode 方法的功能，但是生成的源代码比使用 AutoValue 框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用 IDE 工具生成 equals(和 hashCode) 方法通常比手动编写它们更可取，因为 IDE 工具不会犯粗心大意的错误，而人类则会。 除非必须：在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全是你想要的。 如果你确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。 重写equals方法同时也要重写hashcode方法在每个类中，在重写equals时，一定要重写hashcode。如果不这么做，你的类就违反了hashcode的约定，这会阻止它在HashMap和HashSet这样的集合中正常工作。Object这样规范： 如果没有修改equals方法中用以比较的信息，在应用程序的一次执行过程中对一个对象重复调用hashcode方法时，它必须始终返回相同的值。在应用程序多次执行过程中，每个执行过程在该对象上获取的结果可以不相同。 如果像个对象根据equals(Obejct)方法比较是相等的，那么在两个对象上调用hashcode就必须产生的结果是相同的整数 如果两个对象根据equals(Object)方法比较并不相等，则要求在每个对象上调用hashcode都必须产生不同的结果。但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表的性能 当无法重写hashcode时，所违反的第二个关键条款：相同的对象必须具有相等的哈希码。根据类的equals方法，两个不同的示例可能在逻辑上是相同的，但是对于Object类的hashcode方法，它们知识两个没有什么共同之处的对象。因此，Object类的hashcode方法返回两个看似灰机的数字，而不是按约定要求的两个相等的数字。 举个例子 12Map&lt;PhoneNumber, String&gt; m = new HashMap&lt;&gt;();m.put(new PhoneNumber(707, 867, 5309), \"Jenny\"); 如果没重写hashcode，你本期望m.get(new PhoneNumber(707, 867, 5309)) 方法返回 Jenny 字符串，但是只会返回null。 注意，这里涉及到两个 PhoneNumber 实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。PhoneNumber 类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把 PhoneNumber 实例保存在了一个哈希桶（ hash bucket）中，但 get 方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为 HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。 以下是一个简单的配方： 声明一个 int 类型的变量 result，并将其初始化为对象中第一个重要属性 c 的哈希码，如下面步骤 2.a 中所计算的那样。（回顾条目 10，重要的属性是影响比较相等的领域。） 对于对象中剩余的重要属性 f，请执行以下操作：a. 比较属性 f 与属性 c 的 int 类型的哈希码： – i. 如果这个属性是基本类型的，使用 Type.hashCode(f) 方法计算，其中 Type 类是对应属性 f 基本类型的包装类。 – ii. 如果该属性是一个对象引用，并且该类的 equals 方法通过递归调用 equals 来比较该属性，并递归地调用 hashCode 方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用 hashCode。 如果该字段的值为空，则使用 0（也可以使用其他常数，但通常来使用 0 表示）。 – iii. 如果属性 f 是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤 2.b 的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为 0。如果所有元素都很重要，则使用 Arrays.hashCode 方法。 b. 将步骤 2.a 中属性 c 计算出的哈希码合并为如下结果：result = 31 * result + c; 返回 result 值。 当你写完 hashCode 方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用 AutoValue 框架来生成你的 equals 和 hashCode 方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。 可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在 equals 比较中没有使用的任何属性，否则可能会违反 hashCode 约定的第二条。 步骤 2.b 中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个 String 散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择 31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以 2 相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31 的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：31 * i ==（i &lt;&lt; 5） - i。 现代 JVM 可以自动进行这种优化。 让我们把上述办法应用到 PhoneNumber 类中： 12345678// Typical hashCode method@Override public int hashCode() &#123; int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result;&#125; 因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是 PhoneNumber 实例中的三个重要的属性，所以显然相等的 PhoneNumber 实例具有相同的哈希码。 实际上，这个方法是 PhoneNumber 的一个非常好的 hashCode 实现，与 Java 平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。 总之 ，每次重写equals都必须重写hashcode，否则程序将无法正常运行！","categories":[],"tags":[]},{"title":"linux命令行 （一） 基础篇","slug":"linux命令行-（一）-基础篇","date":"2020-04-11T21:37:38.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/11/linux命令行-（一）-基础篇/","link":"","permalink":"https://createralan.github.io/2020/04/11/linux命令行-（一）-基础篇/","excerpt":"","text":"掌握本文中出现的命令行，将可以处理绝大多数的linux命令操作。 本文中出现的命令一定要熟练掌握，这将是下一篇linux系列的基础 最常用 自言自语 echo echo xiapazi xiapazi echo $PWD /root 我在哪个目录下 pwd (Print Working Directory) pwd /root 切换目录 cd cd /Python-3.7.7 (无返回值) 看看当前目录都有什么 ls ls Python-3.7.7 Python-3.7.7.tgz(当前目录下的文件) ls - l(列表模式) ls -la （列表模式+隐藏文件） ls -lh (带文件大小) 寻求帮助 查看用户手册或帮助 man，通常man更全一些 man -pwd 帮助 -h 或 –help pip -h pip –help 文件内容 打印文件内容 cat(Concatenate and print files) cat a.txt cat a.txt b.txt 打印前n行 head head a.txt (默认打印前10行) head -n 5 打印前五行 打印后n行 tail tail a.txt (默认打印前10行) tail -n 5 a.txt 打印后五行 tail -f a.txt （打印后10行且跟踪这个文件，如果有新内容就会打印出来） 交互浏览 less less a.txt 可以理解为进入到了一个只读模式的vi（vi就是linux下的一种编辑器） 内容查找 在交互模式下 / 进入交互模式后 / 之后输入你想要查找的内容 在命令行中 | grep cat a.txt | grep -n 8 (会显示文件中所有含有8的内容，加了-n之后会显示处于第几行) 单词统计 | wc（Word，line and byte count） cat a.txt | wc 100 100 292(100行，100个单词，292个字节) 重定向和管道 重定向 将输入重定向到文件 &gt; echo hello &gt; hello.txt 将输入重定向追加到文件 &gt;&gt; echo world &gt;&gt; hello.txt 将文件内容重定向至命令行打印出来 &lt; cat &lt;hello.txt 管道 将前一个的输出作为下一个的输入，形成一个工作流 man less | grep sim (进入交互模式且查找sim) man less |grep -n sim | grep That &gt; that.txt (进入交互模式查找sim并显示行号，后在查找包含That，再之后重定向输入到that.txt文件中) 概念补充：Unix哲学 每个程序只做一个事情，并且把这个事情做好 一个程序的输出可以作为另一个程序的输入（管道），不要输出无关的内容 编写处理字符流的程序，因为那是通用接口 编写可以互相协作的程序（因为每个程序只做一件事情，多个程序组合就可以实现复杂的操作）","categories":[],"tags":[]},{"title":"高效java （六） 使用try-with-resources代替try-finally","slug":"高效java-（六）-使用try-with-resources代替try-finally","date":"2020-04-11T15:03:59.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/11/高效java-（六）-使用try-with-resources代替try-finally/","link":"","permalink":"https://createralan.github.io/2020/04/11/高效java-（六）-使用try-with-resources代替try-finally/","excerpt":"","text":"通常情况我们在关闭资源的时候，会使用try-fianlly来关闭资源。 举个例子 123456789// try-finally - No longer the best way to close resources!static String firstLineOfFile(String path) throws IOException &#123; BufferedReader br = new BufferedReader(new FileReader(path)); try &#123; return br.readLine(); &#125; finally &#123; br.close(); &#125;&#125; 看上去也没什么问题，很多情况下我们也都这么做了 但是往往有例外，如果在底层物理设备发生故障，我们可能在readline方法的调用发生了异常，且同样原因close也发生了异常。在这种情况下，第二个异常会冲掉第一个异常。在异常栈堆中没有第一个异常的记录，这可能使实际系统的调式非常复杂–因为原因你想要诊断的是第一个异常，虽然可以编写代码来异常这种异常，但是没有人会这么做，太冗长了。 直到JDK7中主角登场 try-with-resources: 实现这个构造，资源必须实现AutoCloseable接口，该接口返回为void的close组成。java类库和第三方类库中都大部分都继承或实现了AutoCloseable接口。如果你写的类必须关闭资源，请自行继承。 下面是实现的一个例子 1234567// try-with-resources - the the best way to close resources!static String firstLineOfFile(String path) throws IOException &#123; try (BufferedReader br = new BufferedReader( new FileReader(path))) &#123; return br.readLine(); &#125;&#125; 可以看到，这种方式比原始方式更精简，有更好的可读性，而且它们提供了更好的诊断，考虑上面我们说的问题，如果调用readline和close方法都抛出异常，则后一个异常将被抑制。为了保证你真正想看到的异常，可能会抑制多个异常。这些异常没有被抛弃，而是会打印在栈堆中跟踪，并且标注为被抑制了。 结论 在处理必须关闭的资源时，使用try-with-resources代替try-finally。 更简洁 更清晰 异常更有用 更不容易出错","categories":[],"tags":[]},{"title":"高效java （六） 避免使用 Finalizer 和 Cleaner 机制","slug":"高效java-（六）-避免使用-Finalizer-和-Cleaner-机制","date":"2020-04-11T15:03:59.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/11/高效java-（六）-避免使用-Finalizer-和-Cleaner-机制/","link":"","permalink":"https://createralan.github.io/2020/04/11/高效java-（六）-避免使用-Finalizer-和-Cleaner-机制/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"高效Java（五） 消除过期对象的引用","slug":"高效Java（五-消除过期对象的引用","date":"2020-04-10T17:49:38.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/10/高效Java（五-消除过期对象的引用/","link":"","permalink":"https://createralan.github.io/2020/04/10/高效Java（五-消除过期对象的引用/","excerpt":"","text":"在大学时期学CPP的时候 ，总是被垃圾回收机制搞得晕头转向。 学Java的第一天，老师说以后你的对象在使用完毕以后就自动回收了 想起那句，比在一起更快乐的事情，莫过于分手了！ 一个简单的栈实现的例子—不被回收的对象123456789101112131415161718192021222324252627282930// Can you spot the \"memory leak\"?public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if (size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * Ensure space for at least one more element, roughly * doubling the capacity each time the array needs to grow. */ private void ensureCapacity() &#123; if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 这个程序没有错误，但是在极端情况下，这样可能会导致内存泄漏。 因为一个栈增长后收缩，那么弹栈出的对象不会被回收，过期引用简单来说就是永远不会解除的引用。 解决方法：一旦对象引用过期，将他们设置为null。 1234567public Object pop() &#123; if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // Eliminate obsolete reference return result;&#125; 这样的另一个好处就是，如果他们随后被错误的引用，程序可以马上跑出空指针异常，也方便程序员定位错误。 但!这既不是必要的，也不是可取的；它不必要地搞乱了程序。 清空对象引用应该是例外，而不是规范。 那么什么时候应该清空一个引用呢？Stack 类的哪个方面使它容易受到内存泄漏的影响？简单地说，它管理自己的内存。存储池（storage pool）由 elements 数组的元素组成（对象引用单元，而不是对象本身）。数组中活动部分的元素 (如前面定义的) 被分配，其余的元素都是空闲的。垃圾收集器没有办法知道这些；对于垃圾收集器来说，elements 数组中的所有对象引用都同样有效。只有程序员知道数组的非活动部分不重要。程序员可以向垃圾收集器传达这样一个事实，一旦数组中的元素变成非活动的一部分，就可以手动清空这些元素的引用。 一般来说，当一个类自己管理内存时，程序员应该警惕内存泄漏问题。 每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。 另一个常见的内存泄漏来源是缓存。 一旦将对象引用放入缓存中，很容易忘记它的存在，并且在它变得无关紧要之后，仍然保留在缓存中。对于这个问题有几种解决方案。如果你正好想实现了一个缓存：只要在缓存之外存在对某个项（entry）的键（key）引用，那么这项就是明确有关联的，就可以用 WeakHashMap 来表示缓存；这些项在过期之后自动删除。记住，只有当缓存中某个项的生命周期是由外部引用到键（key）而不是值（value）决定时，WeakHashMap 才有用。 更常见的情况是，缓存项有用的生命周期不太明确，随着时间的推移一些项变得越来越没有价值。在这种情况下，缓存应该偶尔清理掉已经废弃的项。这可以通过一个后台线程 (也许是 ScheduledThreadPoolExecutor) 或将新的项添加到缓存时顺便清理。LinkedHashMap 类使用它的 removeEldestEntry 方法实现了后一种方案。对于更复杂的缓存，可能直接需要使用 java.lang.ref。 第三个常见的内存泄漏来源是监听器和其他回调。如果你实现了一个 API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调是垃圾收集的一种方法是只存储弱引用（weak references），例如，仅将它们保存在 WeakHashMap 的键（key）中。 因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（heap profiler）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。","categories":[],"tags":[]},{"title":"高效Java（四）避免创建不必要的对象","slug":"高效Java（四）避免创建不必要的对象","date":"2020-04-09T13:28:03.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/09/高效Java（四）避免创建不必要的对象/","link":"","permalink":"https://createralan.github.io/2020/04/09/高效Java（四）避免创建不必要的对象/","excerpt":"","text":"尽量在需要时重用一个对象而不要创建一个新的相同功能对象，这听上去虽然是一句废话。但是我们在实际场景中往往会忽略掉。本文举两个场景来介绍： 上例子： 12345// Performance can be greatly improved!static boolean isRomanNumeral(String s) &#123; return s.matches(\"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)\" + \"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$\");&#125; VS 12345678910// Reusing expensive object for improved performancepublic class RomanNumerals &#123; private static final Pattern ROMAN = Pattern.compile( \"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)\" + \"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$\"); static boolean isRomanNumeral(String s) &#123; return ROMAN.matcher(s).matches(); &#125;&#125; 结论：方法2往往会比方法1高几倍 这个实现的问题在于它依赖于String.matches方法。虽然String.matched检查字符串是否匹配是实现正则表达式最简单的方式，但是不适合用于性能临界的情况下重复使用。原理是它在内部为正则表达式创建了一个Patter示例，并且只使用它一次，之后它就有资格进行垃圾回收回收。创建Pattern是很昂贵的仓做，因此在多次调用的情况下，将它编译为一个Pattern实例是更优秀的做法。 自动装箱导致的不必要创建对象例子： 1234567// Hideously slow! Can you spot the object creation?private static long sum() &#123; Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum;&#125; 这是一个正确的例子，因为java允许程序员混用基本类型和包装的基本类型，根据需要自动装箱和拆箱。在例子中程序构造了大学2的31方个Long的示例，因为每次往Long类型的sum变量中增加一个long类型构造的示例都要把变量的类型从Long改为long。 如果我们讲Long 改为 long 数据类型。 这将会省去大量的时间，如这个例子，在机器上运行的时间将会有6.3s减低至0.59秒。 说在最后： 这个章节不应该被误解为我们应该尽量避免创建对象，相反，使用构造方法创建和回收小的对象是很廉价的，构造方法只会做很少的显示工作，尤其在JVM上，创建额外的对象以增强程序的清晰度，简单性或功能通常是件好事 除非池中的对象非常重量级，否则通过维护自己的对象池来避免对象创建是一个坏主意。对象池的典型例子就是数据连接。连接成本非常的搞，因此重用这些对象是有意义的。但是一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现在的JVM具有高度优化的垃圾收集器，还是挺厉害的。","categories":[],"tags":[]},{"title":"高效Java（三） 实现Singleton 属性","slug":"高效Java（三）-实现Singleton-属性","date":"2020-04-08T13:54:57.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/08/高效Java（三）-实现Singleton-属性/","link":"","permalink":"https://createralan.github.io/2020/04/08/高效Java（三）-实现Singleton-属性/","excerpt":"","text":"单例是一个仅实例化一次的类。同创表示无状态对象。 下面介绍一下实现单例化的三种方式： 私有构造方法只调用一次，来初始化Elvis.INSTANCE属性。缺少一个公告的或受保护的构造方法，来保证全局的唯一性。 123456// Singleton with public final fieldpublic class Elvis &#123; public static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public void leaveTheBuilding() &#123; ... &#125;&#125; 对所有对象都返回相同的对象引用 12345678// Singleton with static factorypublic class Elvis &#123; private static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public static Elvis getInstance() &#123; return INSTANCE; &#125; public void leaveTheBuilding() &#123; ... &#125;&#125; 声明单一元素的枚举类，类型公共属性方法，但是更简洁，无偿地提供了序列化机智，并提供了防止多个实例化的坚固保证。单一元素枚举通常是实现单例的最佳方式 123456// Enum singleton - the preferred approachpublic enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123; ... &#125;&#125;","categories":[],"tags":[]},{"title":"高效Java（二） builder模式构造","slug":"高效Java（二）builder模式构造","date":"2020-04-07T01:31:02.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/07/高效Java（二）builder模式构造/","link":"","permalink":"https://createralan.github.io/2020/04/07/高效Java（二）builder模式构造/","excerpt":"","text":"构造方法过多时，建议使用builder模式常用的JavaBean缺点： 由于构造方法被分割成了多次调用，所以在构造过程中，JavaBean可能处于不一致的状态。 导致javabean的方法虽然简单易用，但是在不一致的状态下尝试使用对象可能导致一些错误 javabean模式排除了让类不可变得可能性，所以需要增加工序以保证线程安全 Builder模式：结合了可伸缩构造方法模式的安全性和JavaBean模式的可读性 可伸缩构造方法：为各种可选参数单独写构造方法 客户端不需要直接构造所需的对象，而是调用一个包含所有必须参数的构造方法得到一个builder对象。然后调用builder对象的与setter相似的方法来设计可选参数。 实例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Builder Patternpublic class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder &#123; // Required parameters private final int servingSize; private final int servings; // Optional parameters - initialized to default values private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; servingSize = builder.servingSize; servings = builder.servings; calories = builder.calories; fat = builder.fat; sodium = builder.sodium; carbohydrate = builder.carbohydrate; &#125;&#125; NutritionFacts 类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样就可以进行链式调用，从而生成一个流畅的 API。下面是客户端代码的示例： 12NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); Builder 还非常适合类层次结构使用平行层次的 builder，每个builder嵌套在相应的类中。 抽象类有抽象的 builder；具体的类有具体的 builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类： 123456789101112131415161718192021222324252627// Builder pattern for class hierarchiesimport java.util.EnumSet;import java.util.Objects;import java.util.Set;public abstract class Pizza &#123; public enum Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125; final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123; EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) &#123; toppings.add(Objects.requireNonNull(topping)); return self(); &#125; abstract Pizza build(); // Subclasses must override this method to return \"this\" protected abstract T self(); &#125; Pizza(Builder&lt;?&gt; builder) &#123; toppings = builder.toppings.clone(); // See Item 50 &#125;&#125; 请注意，Pizza.Builder 是一个带有递归类型参数（ recursive type parameter）（详见第 30 条）的泛型类型。 这与抽象的 self 方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java 缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）。 这里有两个具体的 Pizza 的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.Objects;public class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private final Size size; public Builder(Size size) &#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private NyPizza(Builder builder) &#123; super(builder); size = builder.size; &#125;&#125;public class Calzone extends Pizza &#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; // Default public Builder sauceInside() &#123; sauceInside = true; return this; &#125; @Override public Calzone build() &#123; return new Calzone(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private Calzone(Builder builder) &#123; super(builder); sauceInside = builder.sauceInside; &#125;&#125; 请注意，每个子类 builder 中的 build 方法被声明为返回正确的子类：NyPizza.Builder 的 build 方法返回 NyPizza，而 Calzone.Builder 中的 build 方法返回 Calzone。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型（covariant return typing）。 它允许客户端使用这些 builder，而不需要强制转换。 这些「分层 builder（hierarchical builders）」的客户端代码基本上与简单的 NutritionFacts builder 的代码相同。为了简洁起见，下面显示的示例客户端代码假设枚举常量的静态导入： 1234NyPizza pizza = new NyPizza.Builder(SMALL) .addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInside().build(); ​ 总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder 模式是一个不错的选择，特别是许多参数是可选的或相同类型的。builder模式客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder模式比 JavaBeans 更安全。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://createralan.github.io/tags/java/"}]},{"title":"高效Java（一） 静态工厂替代构造方法","slug":"高效Java-（一）-静态工厂替代构造方法","date":"2020-04-06T21:43:14.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/06/高效Java-（一）-静态工厂替代构造方法/","link":"","permalink":"https://createralan.github.io/2020/04/06/高效Java-（一）-静态工厂替代构造方法/","excerpt":"","text":"本系列内容总结自Effctive-java-3 https://sjsdfg.github.io/ 静态工厂方法与设计模式中的工厂方法模式不同 普通的创建对象 1Date date = new Date(); new究竟做了什么？ 当我们使用new来构造一个新的类示例时，其实是告诉JVM我们需要一个新的示例。JVM就会在内存中开辟一个新的空间，然后调用构造函数来初始化成员变量，最终把引用返回给调用方。 静态工厂示例：将基本类型boolean转换为 Boolean 对象引用： 123public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 1Boolean flag = Boolean.valueOf(true); 静态工厂的优点 与构造方法不同，它们是有名字的 一个类只能有一个给定签名的构造方法。而静态工厂方法有名字，所以在类中需要具有相同签名的多个构造方法的情况下，可以使用静态工厂替换构造方法 与构造方法不同，它们不需要每次调用都创建一个新的对象 单例的写法大多都是用静态工厂方法来实现的 与构造方法不同，可以返回其返回类型的任何子类型对象 12345678910Class Person &#123; public static Person getInstance()&#123; return new Person(); // 这里可以改为 return new Player() / Cooker() &#125;&#125;Class Player extends Person&#123;&#125;Class Cooker extends Person&#123;&#125; 返回对象的类可以根据输入的参数不同而不同 在编写包含改方法的类时，返回的对象的类不需要存在 缺点 没有公共或保护构造方法的类不能被子类化 不方便查找","categories":[],"tags":[]},{"title":"git（三） rebase把你的线条变整洁","slug":"git（三）-rebase把你的线条变整洁","date":"2020-04-05T22:58:26.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/04/05/git（三）-rebase把你的线条变整洁/","link":"","permalink":"https://createralan.github.io/2020/04/05/git（三）-rebase把你的线条变整洁/","excerpt":"","text":"多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。 每次合并再push后，分支变成了这样： 12345678910111213141516171819$ git log --graph --pretty=oneline --abbrev-commit* d1be385 (HEAD -&gt; master, origin/master) init hello* e5e69f1 Merge branch &apos;dev&apos;|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env| |/ * | 12a631b merged bug fix 101|\\ \\ | * | 4c805e2 fix bug 101|/ / * | e1e9c68 merge with no-ff|\\ \\ | |/ | * f52c633 add merge|/ * cf810e4 conflict fixed 总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？ 其实是可以做到的！ Git有一种称为rebase的操作，有人把它翻译成“变基”。 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： 1234567891011$ git log --graph --pretty=oneline --abbrev-commit* 582d922 (HEAD -&gt; master) add author* 8875536 add comment* d1be385 (origin/master) init hello* e5e69f1 Merge branch &apos;dev&apos;|\\ | * 57c53ab (origin/dev, dev) fix env conflict| |\\ | | * 7a5e5dd add env| * | 7bd91f1 add new env... 注意到Git用(HEAD -&gt; master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： 123456789$ git push origin masterTo github.com:michaelliao/learngit.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： 123456789101112$ git pullremote: Counting objects: 3, done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit d1be385..f005ed4 master -&gt; origin/master * [new tag] v1.0 -&gt; v1.0Auto-merging hello.pyMerge made by the &apos;recursive&apos; strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： 123456$ git statusOn branch masterYour branch is ahead of &apos;origin/master&apos; by 3 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： 123456789$ git log --graph --pretty=oneline --abbrev-commit* e0ea545 (HEAD -&gt; master) Merge branch &apos;master&apos; of github.com:michaelliao/learngit|\\ | * f005ed4 (origin/master) set exit=1* | 582d922 add author* | 8875536 add comment|/ * d1be385 init hello... 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？ 有！ 什么问题？ 不好看！ 有没有解决方法？ 有！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： 123456789101112$ git rebaseFirst, rewinding head to replay your work on top of it...Applying: add commentUsing index info to reconstruct a base tree...M hello.pyFalling back to patching base and 3-way merge...Auto-merging hello.pyApplying: add authorUsing index info to reconstruct a base tree...M hello.pyFalling back to patching base and 3-way merge...Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master) add author* 3611cfe add comment* f005ed4 (origin/master) set exit=1* d1be385 init hello... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程： 123456789Mac:~/learngit michael$ git push origin masterCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done.Total 6 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 1 local object.To github.com:michaelliao/learngit.git f005ed4..7e61ed4 master -&gt; master 再用git log看看效果： 123456$ git log --graph --pretty=oneline --abbrev-commit* 7e61ed4 (HEAD -&gt; master, origin/master) add author* 3611cfe add comment* f005ed4 set exit=1* d1be385 init hello... 远程分支的提交历史也是一条直线。 原文：https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648 廖雪峰的官方网站","categories":[],"tags":[]},{"title":"Jenkins(一) 您的第一个Pipeline","slug":"Jenkins-一-您的第一个Pipeline","date":"2020-03-28T23:51:12.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/03/28/Jenkins-一-您的第一个Pipeline/","link":"","permalink":"https://createralan.github.io/2020/03/28/Jenkins-一-您的第一个Pipeline/","excerpt":"","text":"Jenkins Pipeline（或简称为 “Pipeline”）是一套插件，将持续交付的实现和实施集成到 Jenkins 中。 持续交付 Pipeline 自动化的表达了这样一种流程：将基于版本控制管理的软件持续的交付到您的用户和消费者手中。 Jenkins Pipeline 提供了一套可扩展的工具，用于将“简单到复杂”的交付流程实现为“持续交付即代码”。Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 Jenkinsfile ）中，该文件可以被放入项目的源代码控制库中 将以下代码复制到您的仓库中并命名为JenkinsfileJava Jenkinsfile (Declarative Pipeline) 12345678910pipeline &#123; agent &#123; docker &apos;maven:3.3.3&apos; &#125; stages &#123; stage(&apos;build&apos;) &#123; steps &#123; sh &apos;mvn --version&apos; &#125; &#125; &#125;&#125; 单机Jenkins的New Item菜单 为新工程起一个名字，并选择 Multibranch Pipeline 单击 Add Source 按钮，选择您想要使用的仓库类型并填写详细信息. 单击 Save 按钮，观察您的第一个Pipeline运行！ 您可能需要修改 Jenkinsfile 以便应用在您自己的项目中。尝试修改 sh 命令，使其与您本地运行的命令相同。 在配置好 Pipeline 之后，Jenkins 会自动检测您仓库中创建的任何新的分支或合并请求， 并开始为它们运行 Pipelines。","categories":[],"tags":[]},{"title":"Mysql全文检索（二）停用词","slug":"Mysql全文检索（二）-停用词","date":"2020-03-21T17:40:40.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/03/21/Mysql全文检索（二）-停用词/","link":"","permalink":"https://createralan.github.io/2020/03/21/Mysql全文检索（二）-停用词/","excerpt":"","text":"Mysql全文检索-停用词的使用场景：由于在使用mysql实现检索过程中，储存字段中带有不想被检索出的词。类似html标签，这时我们需使用停用词避免一些字段的搜索 本文相关文档相关语句为Mysql的InnoDB引擎 查看InnoDB禁用列表 1SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DEFAULT_STOPWORD; 定义自己的停用词列表，首先需要定义一个与INNODB_FT_DEFAULT_STOPWORD具有相同机构的表，使用停用词填充它 1INSERT INTO my_stopwords(value) VALUES ('Ishmael'); 建表 123456CREATE TABLE opening_lines (id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,opening_line TEXT(500),author VARCHAR(200),title VARCHAR(200)) ENGINE=InnoDB; 写入数据 123456789INSERT INTO opening_lines(opening_line,author,title) VALUES('Call me Ishmael.','Herman Melville','Moby-Dick'),('A screaming comes across the sky.','Thomas Pynchon','Gravity\\'s Rainbow'),('I am an invisible man.','Ralph Ellison','Invisible Man'),('Where now? Who now? When now?','Samuel Beckett','The Unnamable'),('It was love at first sight.','Joseph Heller','Catch-22'),('All this happened, more or less.','Kurt Vonnegut','Slaughterhouse-Five'),('Mrs. Dalloway said she would buy the flowers herself.','Virginia Woolf','Mrs. Dalloway'),('It was a pleasure to burn.','Ray Bradbury','Fahrenheit 451'); 替换全局停用词表 1SET GLOBAL innodb_ft_server_stopword_table = 'test/my_stopwords'; 在本地环境验证时发现报错，[Err] 1231 - Variable ‘innodb_ft_server_stopword_table’ can’t be set to the value of ‘test/my_stopwords’添加”@”后可用，如下 1SET GLOBAL innodb_ft_server_stopword_table = @'test/my_stopwords'; 新建索引 1CREATE FULLTEXT INDEX idx ON opening_lines(opening_line); 测试是否成功 1SET GLOBAL innodb_ft_aux_table='test/opening_lines'; 1SELECT word FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE LIMIT 15; 本文引用自","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://createralan.github.io/categories/Mysql/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://createralan.github.io/tags/搜索/"}]},{"title":"Mysql全文检索（一）简介","slug":"Mysql全文检索（一）-简介","date":"2020-03-07T21:19:42.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/03/07/Mysql全文检索（一）-简介/","link":"","permalink":"https://createralan.github.io/2020/03/07/Mysql全文检索（一）-简介/","excerpt":"","text":"为什么选用MYSQL作为搜索引擎？1. 选用Elasticsearch搜索引擎作为搜索模块的实现Elasticsearch是一个高度可伸缩的开源全文搜索和分析引擎。可以快速和接近实时地存储、搜索和分析大量数据。可以满足搜索功能的实际场景。 优点：功能强大，天生支持分布式，扩展性强，支持海量数据搜索，插件丰富，文档完备，平台已有相关Elasticsearch API，支持高亮查询，支持文件检索。 缺点：资源占用过大 2. MongoDB数据库的全文索引作为搜索模块的实现MongoDB是通用功能的非Restful风格的NoSQL数据库，文档以Bson格式存储，主要用于数据存储，MongoDB 3.2+ 支持了对中文的检索 优点：相对于Elasticsearch更轻量，支持全文检索，部署方便，有扩容方案 缺点: 对于中文的全文检索支持不友好，暂无中文分词器 如图为测试MongoDB对中文全文检索的能力是否支持，因无法对中文完成分词所以无法满足搜索场景 3. MySQL5.7的全文检索作为搜索模块的实现优点：支持中文的全文检索，与平台现有架构相符，与Elasticsearch相比无须将数据二次插入到其他数据库中。 缺点：对海量数据支持性能较差 以下为Mysql检索性能测试数据对比 说明： 1 测试数据集中每条数据被建立索引的字段长度平均为700个字符。 2 测试结果皆为建立完全文索引后的查询速度结果。 3 因全文搜索有三种模式，测试选用更符合场景的NATURAL LANGUAGE MODE和BOOLEAN MODE进行测试。 4 高频字段测试为测试集中较多文档内容中都含有该关键字的查询,SQL使用为优化后的分页查询方法。 查询方式/数据量 50万 100万 200万 500万 LANGUAGE MODE &lt;0.1s 0.3-0.7s 0.3-1.0s 1.1s-4s BOOLEAN MODE &lt;0.05s 0.1-0.3s 0.1-0.5s 0.1-0.7s 高频字段查询(优化) 0.05-0.5s 0.3-1s 0.8s-3s 4-10s 下图是测试100万条数据过程中，对于出现”喜欢”关键字的查询结果截图。 五、结论如果百万级以下的数据量就用mysql如果不差钱或者就想要好的，就选es如果只做英文且想要性价比就选mongodb","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://createralan.github.io/tags/搜索/"}]},{"title":"Elasticsearch (三) 并发冲突","slug":"Elasticsearch-三-并发冲突","date":"2020-03-01T00:58:34.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/03/01/Elasticsearch-三-并发冲突/","link":"","permalink":"https://createralan.github.io/2020/03/01/Elasticsearch-三-并发冲突/","excerpt":"","text":"ES是乱序的，异步并发的 我们的请求是并发的，这意味着，请求到达的目的地是不可控的，乱序的。 如果是乱序的，很可能出现一个问题，新的version文档被旧的version文档覆盖掉，或直接抛异常 ES的乐观锁 ElasticSeach用_version来保证变更以正确的执行，如果旧版本的文档在新版本之后到达，则会被忽略 新建一个文档，这个时候我们可以看到新文档的版本号_version=1： 12345PUT /website/blog/1/_create&#123; &quot;title&quot; : &quot;this is title&quot; , &quot;txt&quot; : &quot;just do it&quot;&#125; 现在尝试通过重建文档索引来保存修改数据： 请求成功，并且响应体告诉我们 _version 已经递增到 2 12345PUT /website/blog/1?version=1&#123; &quot;title&quot; : &quot;this is test&quot; , &quot;txt&quot; : &quot;just do it&quot;&#125; 通过Elasticsearch外部版本控制 version_type=external，只有当你提供的version比_version大的时候，才能修改完成 version_type=external能够修改的条件就是：提供的版本号必须比_version大 现在我们更新这个文档，指定一个新的 version 号是 10 ： 12345PUT /website/blog/2?version=10&amp;version_type=external&#123; &quot;title&quot;: &quot;My first external blog entry&quot;, &quot;text&quot;: &quot;This is a piece of cake...&quot;&#125; 如果此时插入版本号比现在的_version小的，就会报错： 重复提交retry_on_conflict elasticsearch设计的目的就是多用户的海量数据操作； 那么可能存在这样场景：A进程接收到请求尝试去检索(retrieve)和重建索引(reindex)某个文档C，B进程也接收到请求检索(retrieve)和重建索引(reindex)文档C； 那么这个时候就会出现：其中一个进程提前修改了文档C，然后另一个进程在做检索的时候，因为_version改变了，所以匹配不到文档C，操作就会失败，然后数据丢失 这就是在并发操作的时候经常出现的现象； 解决： 对于多用户的更新操作，文档被修改了并不要紧，如果出现了匹配不到的现象，我们只要重新在操作一遍就可以了；所以需要使用关键字retry_on_conflict（默认0） 1234567POST /website/pageviews/1/_update?retry_on_conflict=5&#123; &quot;script&quot; : &quot;ctx._source.views+=1&quot;, &quot;upsert&quot;: &#123; &quot;views&quot;: 0 &#125;&#125; retry_on_conflict=5 代表如果出现失败，最大可以重复五次的update操作","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://createralan.github.io/tags/elasticsearch/"}]},{"title":"Elasticsearch (二) API的使用","slug":"Elasticsearch-二-API的使用","date":"2020-02-26T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/02/26/Elasticsearch-二-API的使用/","link":"","permalink":"https://createralan.github.io/2020/02/26/Elasticsearch-二-API的使用/","excerpt":"","text":"Index APIIndex API 允许我们储存一个JSON格式的文档，使数据可以被搜索。 文档通过index，type，id唯一确定。我们可以自己提供一个ID，也可以使用Index API为我们生成一个。 生成JSON格式的document有以下方式 手动拼接 String json = {“…”} Map方式 Map json = new HashMap… 序列化方式，es已经使用了jackson。可以直接使用它把javaben转为json 123456// instance a json mapper ObjectMapper mapper = new ObjectMapper();// create once, reuse // generate json byte[] json = mapper.writeValueAsBytes(csdn); IndexResponse response = client.prepareIndex(&quot;fendo&quot;, &quot;fendo date&quot;) .setSource(json) .get();System.out.println(response.getResult()); ES内置了一个帮助类：XContentBuilder来生成JSON文档（暂略） GET API当单线程时：（下面的例子是 operationThreaded 设置为 false ） 1GetResponse response = client.prepareGet(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot; ) .setOperationThreaded(false) .get(); DELETE API1DeleteResponse response = client.prepareDelete(&quot;twitter&quot;, &quot;tweet &quot;, &quot;1&quot;) .setOperationThreaded(false) .get(); DELETE BY QUERY API按条件删除 1BulkByScrollResponse response = DeleteByQueryAction.INSTANCE.newRequestBuilder(client) .filter(QueryBuilders.matchQuery(&quot;gender&quot;, &quot;male&quot;)) //查 询条件 .source(&quot;persons&quot;) //index(索引名) .get(); //执行 long deleted = response.getDeleted(); //删除文档的数量 UPDATE API有两种方式更新索引： UpdateRequest 1UpdateRequest updateRequest = new UpdateRequest(); updateRequest.index(&quot;index&quot;); updateRequest.type(&quot;type&quot;); updateRequest.id(&quot;1&quot;); updateRequest.doc(jsonBuilder() .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject()); client.update(updateRequest).get(); prepareUpdate 123client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;) .setScript(new Script(&quot;ctx._source.gender = \\&quot;male\\&quot;&quot; , ScriptService.ScriptType.INLINE, null, null)).get();//脚本可以是本地文件存 储的，如果使用文件存储的脚本，需要设置 //ScriptService.ScriptType.FILE client.prepareUpdate(&quot;ttl&quot;, &quot;doc&quot;, &quot;1&quot;) .setDoc(jsonBuilder() .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject()) .get(); 还有一个Upset 更新插入，如果存在文档就更新，如果不存在就插入 12IndexRequest indexRequest = new IndexRequest(&quot;index&quot;, &quot;type&quot;, &quot;1 &quot;) .source(jsonBuilder() .startObject() .field(&quot;name&quot;, &quot;Joe Smith&quot;) .field(&quot;gender&quot;, &quot;male&quot;) .endObject()); UpdateRequest updateRequest = new UpdateRequest(&quot;index&quot;, &quot;type&quot;, &quot;1&quot;) .doc(jsonBuilder() .startObject() .field(&quot;gender&quot;, &quot;male&quot;) .endObject()) .upsert(indexRequest); client.update(updateRequest).get(); Multi Get Api一次获取多个文档 1234567MultiGetResponse multiGetItemResponses = client.prepareMultiGet( ) .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;1&quot;) //一个id的方式 .add(&quot;twitter&quot;, &quot;tweet&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) //多个id的方式 .add(&quot;another&quot;, &quot;type&quot;, &quot;foo&quot;) //可以从另外一个索引获取 .get();for (MultiGetItemResponse itemResponse : multiGetItemResponses) &#123; //迭代返回值GetResponse response = itemResponse.getResponse(); if (response.isExists()) &#123; String json = response.getSourceAsString(); &#125; &#125; [TOC] 更多请查看https://inventory-manager.oss-cn-beijing.aliyuncs.com/data/elasticsearch-java.pdf","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://createralan.github.io/tags/elasticsearch/"}]},{"title":"AI编程-Hilens-前提篇","slug":"AI编程-Hilens-前提篇","date":"2020-02-20T01:31:02.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/02/20/AI编程-Hilens-前提篇/","link":"","permalink":"https://createralan.github.io/2020/02/20/AI编程-Hilens-前提篇/","excerpt":"","text":"Hilens 的入门经过简单的人脸识别技能安装后，我陷入了迷茫状态 。不知道拿它来做什么 所以今天从应用场景和需准备的工作两个角度对整体有一个了解 1.场景 普通用户： 安装技能，选购安装人脸识别，车牌识别，安全帽识别等 开发者： 在Hilens管理控制台进行开发，端侧集成了Skill Framework框架，封装基础框架，提供API接口（买来之后发现这步并不方便，毕竟现在连开发者技能入门都失败了，日志也看不了 ，不知道什么原因） 摄像头厂商：海思等。不展开讨论 家庭职能监控 人形检测 陌生人检测 摔倒检测 哭声检测 词汇识别（如“救命”） 人脸属性 时光相册 园区只能监控 人脸识别闸机 车牌识别 安全帽识别 轨迹还原（将多个摄像头识别出的人脸，协同分析还原前进途径） 商超检测 客流量 VIP识别 新老顾客同级 人流热力图 职能车载 疲劳驾驶 姿势分析 对周围车辆检测，用于盲区检测 2. 准备工作所需其他的服务 ModelArts OBS（对象存储） 设备日志：https://support.huaweicloud.com/usermanual-hilens/hilens_02_0052.html 技能概念列表： Caffe 算子 算子边缘 TensorFlow Skill Framework 简介：https://support.huaweicloud.com/devg-hilens/hilens_05_0002.html 初始化 输入模块 预处理模块 模型管理模块 输出模块 资源管理模块 日志模块 错误码 修订记录 此页面 可以用于学习打卡，并无实际学习记录（凌晨两点了）","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"hilens","slug":"hilens","permalink":"https://createralan.github.io/tags/hilens/"}]},{"title":"网络知识 （一）NS,DNS,网关","slug":"网络知识-（一）-NS-DNS-网关","date":"2020-02-15T21:19:42.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/02/15/网络知识-（一）-NS-DNS-网关/","link":"","permalink":"https://createralan.github.io/2020/02/15/网络知识-（一）-NS-DNS-网关/","excerpt":"","text":"DNS,IP地址,网关？这都是什么IP地址 常见的IP地址分为公网IP，内网IP IP地址 == 网络地址（网段）+主机地址 如：IP地址192.168.100.1 == 网络地址192.168.100.0 + 主机地址0.0.0.1 两个设备间的联通 两个设备网络地址相同且主机地址不同则可以联通 通过网关联通： 若A主机发现数据包目的主机不在本地网络中，就把数据包发送到自己的网关，再由A网关发送给B网关，B网关发给B主机 默认网关 原两台主机间通信时，如果网络地址不同则无法通信，网关起到转发的作用 设计方法： 手动设置：默认网关的地址须是主机所在的网段IP地址 自动设计：DHCP，自动获取网关（推荐方法） 英文：GATWAY 子网掩码判断任意两台设备的地址是否属于同一网络的根据 实现方法：两台计算各自的IP地址与各自子网掩码进行and运算，得出结果后，则说明这两台设备处于同一网络 nameserver和dns的关系 DNS服务器：把域名翻译成IP地址 DS（nameserver）: 域名服务器，用来指定该域名由那个DNS服务器来解析 A记录：域名对应的IP记录（可以理解成数据表里的单条记录） PS：使用哪里的NS，相应的解析记录（A记录，CNAME等）就需要再哪里设置，比如域名是在万网注册的，NS被改成了GoDaddy的，那么以后解析就需要再GoDaddy里做，万网的记录不会再生效。 补充相关知识点1. LAN口和WAN口的区别?WAN口用来连接外网，LAN口连接内网 一般情况下，LAN口下的主机组成了局域网，设备间可以互相发现 2. 输入URL后网络通信中发生了什么?（以下回答引用自：https://blog.csdn.net/zgege/article/details/81587502） 1，在应用层输入url 用户输入https://mp.csdn.net时，其中http表示采用http协议进行传输,mp.csdn.net为网络地址，表示请求的资源在那个位置（主机）。一般网络地址为IP地址，此处为域名，是IP地址的包装。为了让用户方便使用。 2.应用层DNS解析域名，获得对端IP地址 计算机在通信时是通过IP地址辨识，而不是域名。域名查找顺序：本地缓存-&gt;系统缓存-&gt;浏览器缓存-&gt;ISP缓存-&gt;根域名服务器-&gt;主域名服务器 如果本地缓存有就直接使用，并不是每一个过程都需要走。没有才继续往下走。直到获得IP地址。 3.应用层客户端发送HTTP请求 HTTP请求包括请求报头和请求主体。其中请求报头中包含了请求方法，请求资源，请求所使用放入协议（http,smtp等），以及返回的资源是否需要缓存，客户端是否需要发送cookie等。 4.传输层TCP传输报文 位于传输层的TCP协议提供可靠的字节流服务，他为了方便传输，将大块的数据分割成以报文段为基本单位的数据包进行管理。并未他们编号。方便接收端收到报文后进行组装，还原报头信息。 为了保证可靠性传输，TCP采用三次握手来保证可靠性传输。 5.网络层IP协议查询MAC地址 IP协议把TCP分割的数据包传送给接收方。而要保证却是能够传送给对方主机还需要MAC地址，也就是物理地址。IP地址和MAC地址是一一对应关系。一个设备有且只有一个MAC地址。IP地址可以更换，MAC不会变。ARP协议就是讲IP协议转换成MAC地址的协议，利用ARP协议，找到MAC地址，当通信的双方不在同一个局域网时，还需要多次中转，才能到达目标，在中转时，通过下一个MAC地址来搜索下一个中转目标。 6.数据到达链路层 找到对方的MAC地址后，就将数据包放到链路层进行传输，封装上链路层特有的报头，然后交付给物理层，物理层通过实际的电路如双绞线进行传输。 走到数据链路层，客户端的请求发送阶段完毕。 7.服务器接受请求 服务端主机的网卡接收到数据后，驱动操作系统拿到数据，自下而上进行解包，数据包到链路层，就解析客户端在链路层封装的报头信息，提取报头信息内容，如目标MAC地址，IP地址等。 到达网络层，提取IP协议报头信息，到达传输层，解析传输层协议报头， 到达应用层，解析HTTP报头信息，获得客户端请求的资源和方法。查找到资源后。将资源返回给客户端，并返回响应报文。 响应报文中包括协议名称/协议版本，状态码，状态码描述等信息。其中常见状态码：200 表示请求资源成功。301：永久重定向，表示资源已经永久性重定向到指定位置。 8.请求成功返回相应资源请求成功后，服务器会返回相应的HTMML文件，该文件的传输方式又会从应用层出发，自上问下传送，到达对端时，自下而上进行解析。 以上由于在配置华为云HIlens设备时遇到一些名词概念不理解，所以产出本文。 配置失败根本原因还是自己读文档的时候容易跳跃，","categories":[{"name":"网络","slug":"网络","permalink":"https://createralan.github.io/categories/网络/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://createralan.github.io/tags/linux/"}]},{"title":"Elasticsearch (一) Elasticsearch 安装及介绍","slug":"Elasticsearch-一-Elasticsearch-安装及介绍","date":"2020-02-09T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/02/09/Elasticsearch-一-Elasticsearch-安装及介绍/","link":"","permalink":"https://createralan.github.io/2020/02/09/Elasticsearch-一-Elasticsearch-安装及介绍/","excerpt":"","text":"Elasticsearch 实现多字段高亮检索、文件检索、数据同步Elasticsearch知识： ES概述简介 Elasticsearch是一个分布式的基于REST接口的为云而设计的搜索引擎。 Elasticsearch不仅仅是Lucene和全文搜索引擎，它还提供： 分布式的实时文件存储，每个字段都被索引并可被搜索 实时分析的分布式搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据 为什么选择ES做搜索引擎： 很简便的横向扩容，既能由数百台到万台机器搭建满足PB级的快速搜索，也能搭建单机版服务小公司。 功能点多但使用比较简便，开箱即用，性能优化比较简单 生态圈丰富，社区活跃，apache 2.0开源。适配多种工具。提供java api和restful接口，ELK架构处理海量日志，丰富的插件(分词器、search-gurad等安全插件) ES 相关术语概念 Cluster:Cluster也就是集群的意思。Elasticsearch集群由一个或多个节点组成，可通过其集群名称进行标识。通常这个Cluster 的名字是可以在Elasticsearch里的配置文件中设置的。 node:单个Elasticsearch实例。 在大多数环境中，每个节点都在单独的盒子或虚拟机上运行。一个集群由一个或多个node组成。 Document:Elasticsearch是面向文档的，这意味着您索引或搜索的最小数据单元是文档。 type:类型是文档的逻辑容器，类似于表是行的容器。 index :在Elasticsearch中，索引是文档的集合。 shard :由于Elasticsearch是一个分布式搜索引擎，因此索引通常会拆分为分布在多个节点上的称为分片的元素。 replica :默认情况下，Elasticsearch为每个索引创建一个主分片和一个副本。 ES DEMO说明：此例适用于elasticsearch6.4.3，其他版本尚未测试 实现目标： 针对于文档的标题，内容及相关属性（如标签、时间），提供输入关键字即可搜索的能力 关键字在搜索结果中高亮显示 搜索功能实现对于文件的检索，如word、pdf等。（使用Ingest Attachment Processor） ES索引中的文档与mysql数据库中的数据同步（使用logstash） 环境要求： elasticsearch 6.4.3 es下载地址：https://www.elastic.co/cn/downloads/past-releases/elasticsearch-6-4-3 安装指导：https://blog.csdn.net/art_code/article/details/90499981 ik分词器6.4.3 PS：为什么选择IK分词器？支持中文；功能强大；开源；仍被维护。 ik下载地址：https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.3/elasticsearch-analysis-ik-6.4.3.zip 安装指导：https://www.cnblogs.com/chenmc/p/9525163.html 其他工具：Ingest Attachment Processor、logstash 工具类的使用： 对比开源的相关es搜索工具类（如Bboss，elasticsearch-RHL等）且 根据项目需求（检索条件不复杂，仅针对于文档）。认为spring-boot-starter-data-elasticsearch（可认为spring-data官方的工具类）较适合于目前知识库的elasticsearch工具类选用。maven工程中pom文件如下 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; 工具类的API使用概述及配置（详情见DEMO） appliction.properties参数 1234## Elasticsearch配置文件（必须）## 该配置和Elasticsearch的elasticsearch.yml中的配置信息有关spring.data.elasticsearch.cluster-name=my-applicationspring.data.elasticsearch.cluster-nodes=127.0.0.1:9300 创建接口继承ElasticsearchRepository，其中为自定义的实体类 1public interface DemoRepository extends ElasticsearchRepository&lt;Demo,Long&gt; &#123; 在实现类中，使用根据自定义实体类创建好的接口及ES的模板类 12345@Autowiredprivate ItemRepository itemRepository;@Autowiredprivate ElasticsearchTemplate elasticsearchTemplate;...(具体操作见DEMO代码) ​ GitHub仓库地址： 文件检索的实现 ingest attachment plugin允许Elasticsearch通过使用Apache文本提取库Tika提取通用格式（例如PPT，XLS和PDF）的文件附件。 Apache Tika工具包可从一千多种不同的文件类型（例如PPT，XLS和PDF）中检测并提取元数据和文本。 所有这些文件类型都可以通过一个界面进行解析，从而使Tika对搜索引擎索引，内容分析，翻译等有用。 源字段必须是base64编码的二进制。 创建attachment pipeline 我们可以在我们的Ingest node上创建一个叫做pdfattachment的pipleline: 1234567891011PUT _ingest/pipeline/pdfattachment&#123; &quot;description&quot;: &quot;Extract attachment information encoded in Base64 with UTF-8 charset&quot;, &quot;processors&quot;: [ &#123; &quot;attachment&quot;: &#123; &quot;field&quot;: &quot;file&quot; &#125; &#125; ] 转换pdf文件并上传pdf文件的内容到Elasticsearch中 对于ingest attachment plugin来说，它的数据必须是Base64的。我们可以在网站Base64 encoder来进行转换。针对我们的情况，我们直接通过脚本的方法来进行操作： 12345#!/bin/bashencodedPdf=`cat sample.pdf | base64`json=&quot;&#123;\\&quot;file\\&quot;:\\&quot;$&#123;encodedPdf&#125;\\&quot;&#125;&quot;echo &quot;$json&quot; &gt; json.filecurl -XPOST &apos;http://localhost:9200/pdf-test1/_doc?pipeline=pdfattachment&amp;pretty&apos; -H &apos;Content-Type: application/json&apos; -d @json.file 数据同步的实现 需满足条件 在将 MySQL 中的文档写入 Elasticsearch 时，Elasticsearch 中的 “_id” 字段必须设置为 MySQL 中的 “id” 字段。这可在 MySQL 记录与 Elasticsearch 文档之间建立一个直接映射关系。如果在 MySQL 中更新了某条记录，那么将会在 Elasticsearch 中覆盖整条相关记录。请注意，在 Elasticsearch 中覆盖文档的效率与更新操作的效率一样高，因为从内部原理上来讲，更新便包括删除旧文档以及随后对全新文档进行索引。 当在 MySQL 中插入或更新数据时，该条记录必须有一个包含更新或插入时间的字段。通过此字段，便可允许 Logstash 仅请求获得在轮询循环的上次迭代后编辑或插入的文档。Logstash 每次对 MySQL 进行轮询时，都会保存其从 MySQL 所读取最后一条记录的更新或插入时间。在下一次迭代时，Logstash 便知道其仅需请求获得符合下列条件的记录：更新或插入时间晚于在轮询循环中的上一次迭代中所收到的最后一条记录。 Logstash通过管道同步数据： 123456789101112131415161718192021222324252627input &#123; jdbc &#123; jdbc_driver_library =&gt; &quot;&lt;path&gt;/mysql-connector-java-8.0.16.jar&quot; jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_connection_string =&gt; &quot;jdbc:mysql://&lt;MySQL host&gt;:3306/es_db&quot; jdbc_user =&gt; &lt;my username&gt; jdbc_password =&gt; &lt;my password&gt; jdbc_paging_enabled =&gt; true tracking_column =&gt; &quot;unix_ts_in_secs&quot; use_column_value =&gt; true tracking_column_type =&gt; &quot;numeric&quot; schedule =&gt; &quot;*/5 * * * * *&quot; statement =&gt; &quot;SELECT *, UNIX_TIMESTAMP(modification_time) AS unix_ts_in_secs FROM es_table WHERE (UNIX_TIMESTAMP(modification_time) &gt; :sql_last_value AND modification_time &lt; NOW()) ORDER BY modification_time ASC&quot; &#125;&#125;filter &#123; mutate &#123; copy =&gt; &#123; &quot;id&quot; =&gt; &quot;[@metadata][_id]&quot;&#125; remove_field =&gt; [&quot;id&quot;, &quot;@version&quot;, &quot;unix_ts_in_secs&quot;] &#125;&#125;output &#123; # stdout &#123; codec =&gt; &quot;rubydebug&quot;&#125; elasticsearch &#123; index =&gt; &quot;rdbms_sync_idx&quot; document_id =&gt; &quot;%&#123;[@metadata][_id]&#125;&quot; &#125; 参考文档: https://elasticstack.blog.csdn.net/article/details/99443042 （基础概念） https://elasticstack.blog.csdn.net/article/details/102728604 （入门指南） https://elasticstack.blog.csdn.net/article/details/99413578 (安装文档) https://elasticstack.blog.csdn.net/article/details/104171230 （对文档搜索） https://elasticstack.blog.csdn.net/article/details/103874185 （数据同步） 示例代码","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://createralan.github.io/tags/elasticsearch/"}]},{"title":"git (二) git标签、Stash管理","slug":"git-二-git标签、Stash管理","date":"2020-01-19T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/01/19/git-二-git标签、Stash管理/","link":"","permalink":"https://createralan.github.io/2020/01/19/git-二-git标签、Stash管理/","excerpt":"","text":"标签 打tag： 附注标签：git tag -a v1.4 -m “my version 1.4” 轻量标签：git tag v1.4 后期打标签：git tag -a v1.4 &lt;提交校验和&gt;（如9fceb02） 列出标签 ： git tag 共享标签: git push origin v1.5 共享某个分支到服务器 git push origin –tags 一次性推送很多标签 删除标签：git tag -d v1.4 检出标签：git checkout 会使你的库处于“分离头指针”的状态。大部分情况下不适用。 Stash git stash save “save message” ：执行储存时，添加备注，方便查找 git stash list ：查看stash了那些储存 git stash show ：显示做了那些改动，如不加stash num，默认显示第一个 git stash apply ：应用某个储存,默认使用第一个 git stash pop ：命令恢复之前缓存的工作目录。将缓存栈堆中的对应stash删除 git stash drop ：删除某个stash git stash clear ：删除所有缓存的stash 账户管理 全局： git config –global user.name “tongziqi” git config –global user.email “tongziqi@qq.com“ 某个仓库内 git config user.name “tongziqi” git config user.email “tongziqi@qq.com“ 查看配置信息: git config –list “HEAD” 是什么？分支，本质上仅仅是指向commit对象可变指针。但怎么知道你当前在哪个分支上工作？ 它保存着一个HEAD的特别指针，HEAD指向你当前的工作。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"git","slug":"git","permalink":"https://createralan.github.io/tags/git/"}]},{"title":"Scrum指南总结","slug":"敏捷开发-六-scrum指南总结","date":"2020-01-15T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/01/15/敏捷开发-六-scrum指南总结/","link":"","permalink":"https://createralan.github.io/2020/01/15/敏捷开发-六-scrum指南总结/","excerpt":"","text":"Scrum指南总结Scrum指南概览包括了Scrum角色、事件、工件、以及把他们组织在一起的规则 Scrum的定义Scrum是一个框架。在此框架中人们可以解决复杂的自适应难题，同时高效并创造性的交付可能最高的价值 Scrum是轻量的、易于理解的、难以精通的 Scrum 理论Scrum 基于经验过程控制理论，或简言之为经验主义 经验主义主张知识源自实际经验以及当前已知情况下做出的决定所得。 Scrum 采用增量式迭代来优化对未来的预测和控制风险 经验过程控制的三大支柱： 透明：过程中的关键环节对于产出负责的额嗯必须是透明的。（要拥有透明，就要为关键环节制定统一标准，如参与者在过程中必须使用统一术语，对比如“完成”等定义必须有一致理解） 检视：Scrum的使用者必须经常检视Scrum工件和完成Sprint的进展。以便发现不必要的差异。检视不应该过于繁琐而影响本身所以检视最好由技能娴熟的成员执行 适应：如果检视者发现过程中一个或多个方面偏离可接受范围。必须对过程的内容加以调整，调整到最小化进一步的偏差 Scrum的正式事件，用于检视与适应： Sprint 计划会议 每日Scrum站会 Sprint评审会议 Sprint回顾会议 Scrum价值观 承诺 勇气 专注 开放 尊重 当5个价值观为官推所践行与内化，透明、检视、适应三大支柱成为现实 人们致力于实现Scrum团队的目标。Scrum团队成员有勇气去做正确的事并处理那些棘手的问题，每个人专注于Sprint的工作和Scrum团队的目标。Scrum团队及利益攸关者同意将所有工作和执行工作上的挑战进行公开。Scrum团队成员相互尊重，彼此是有能力和独立的人。 Scrum团队一名产品负责人+Scrum Master（敏捷教练）+开发团队 Scrum团队是跨职能的自组织团队。跨职能团队用为完成工作所需的全部技能 自组织团队自己选择如何以最好的方式完成工作，而不是由团队之外的人来指导 产品负责人 其职能是将开发团队的产品价值最大化。产品负责人是负责管理产品待办列表的唯一负责人 产品代办列表包括 清晰地表述产品代办列表项 对产品代办列表进行排序，使其最好地实现目标 优化开发团队所执行工作的价值 保证列表对所有人可见，透明、清晰。同事显示Scrum团队下一步要做的工作 确保开发团队对产品待办列表项有足够深的了解 注意：产品负责人是一个人，不是一个委员会。想要改变产品的代办列表项的优先级必须经过产品负责人。组织中所有人员必须尊重他/她的决定 开发团队 Scrum Master Scrum事件 Sprint 每个Sprint都可以被视为一个项目，为期不超过一个月。就如同项目一样，Sprint被用于完成某些事情。每个Sprint都会有一个要构建什么的目标。还有一份设计过和灵活的计划用来指导如何做这件事 在Sprint期间： 不能做出有害于Sprint目标的改变。 不能降低质量的目标 随着对信息掌握的增加，产品负责人与开发团队之间对范围内要做的事可以加以澄清和重新协商 Sprint计划会议 Sprint计划回忆回答一下两个问题： 这次Sprint能做什么？ 产品负责人讲解Sprint的目标以及达成该目标所需完成的产品代办列表项。整个Scrum团队协同工作来理解Sprint的工作。Sprint会议的输入时产品待办列表、最新的产品增量、开发团队在这个Sprint中的能力预测以及开发团队的以往表现。开发团队自己决定选择产品待办列表的数量。只有开发团队可以评估接下来Sprint可以完成什么工作。 如何完成所选的工作？ 设定了Sprint目标并选出这个Sprint要完成的产品代办列表项之后。开发团队奖决定如何在Sprint中把这些功能构建成“完成”的产品增量。这个Sprint中所炫出的产品代办列表项加上如何交付他们的设计成为Sprint待办列表 Scrum站会 站会是开发团队的一个时间盒设定为15分钟的时间。每日的Scrum站会都在Sprint的每一天举行。站会上开发团队为杰西莱的24小时的工作制定计划。通过检视上次每日Scrum站会依赖的工作和预测即将到来的Sprint工作来优化团队协作和效能。 以下是一个可以使用的范例： 昨天，我为帮助开发团队达成Sprint目标做了什么? 今天，我为帮助开发团队达成Sprint目标准备做什么？ 是否有任何障碍在阻碍我或开发团队达成Sprint目标？ Sprint评审会议 对弈长度为一个月的Sprint来说，评审会议时间最长不超过4小时。 对于较短的Sprint来说，会议时间通常会缩短。 评审会议包含以下内容 参会者包括Scrum团队和产品负责人邀请的主要利益攸关者 产品负责人说明那些产品待办项已经“完成”和那些没有“完成” 开发团队讨论在Sprint期间那些工作做得好，遭遇到什么问题，是如何解决的 开发团队演示“完成”的工作并解答关于所交付增量的问题 产品负责人讨论当前的产品待办列表的情况。跟库目前为止的进度来预测可能得目标交付日期 参会的所有人就下一步的工作进行讨论。这样就能为接下来的Sprint计划回忆提供有价值的输入信息 评审市场或潜在的产品使用方式所带来的接下来的做的最有价值的东西的改变 评审会议的结果是一份修订后的产品待办列表，阐明很可能进入下个Sprint的产品代办列表项 Sprint回顾会议 Sprint 回顾会议是 Scrum 团队检视自身并创建下一个 Sprint 改进计划的机会。 回顾会议发生在 Sprint 评审会议结束之后，下个 Sprint 计划会议之前。对于长度为一个 月的 Sprint 来说，回顾会议时间最长不超过 3 小时。对于较短的 Sprint 来说，会议时 间通常会缩短。Scrum Master 要确保会议举行，并且每个参会者都明白会议的目的。 Scrum Master 确保会议是积极的和富有成效的。 Scrum Master 教导大家遵守时间盒的规 则。Scrum Master 对 Scrum 过程负责，作为团队的一员参加该会议。 Sprint 回顾会议的目的在于： 检视前一个 Sprint 中关于人、关系、过程和工具的情况如何； 找出并加以排序做得好的和潜在需要改进的主要方面； 同时， 制定改进 Scrum 团队工作方式的计划。 Scrum工件Scrum的工件以不同的方式表现工作的任务和价值，可以用来提供透明以及检视和适合的机会 Scrum依赖于透明。优化价值和控制风险的决定都是局域所获知的工件状态。当工件的状态是完全透明时。这些做出的决定才有一个坚实的基础。 “完成”的定义当产品待办列表项或增量被描述为“完成”时，每个人都必须理解“完成”意味着什么。虽然 在不同 Scrum 团队之间或许会存在显著差异，但是每个团队成员必须对完成工作意味着什 么有相同的理解以便确保透明化。这就是 Scrum 团队的“完成”定义，用来评估产品增量 是否完成。 这一定义也同时被用来指导开发团队了解在 Sprint 计划会议时能够选择多少产品待办列表 项。每个 Sprint 的目标在于交付符合 Scrum 团队当前“完成”的定义的潜在可交付功能 增量。 开发团队在每个 Sprint 都交付产品功能增量。这一增量是可用的，所以产品负责人可以 选择立即发布它。如果“完成”的定义对增量来说是开发组织的惯例、标准或指南，那么所 有 Scrum 团队都必须遵守它，以此为最低标准。 如果增量“完成”的定义不是开发组织的惯例，那么 Scrum 团队中的开发团队就必须制定 适合于产品的“完成”的定义。如果系统或产品发布由多个 Scrum 团队一起开发，那么所 有 Scrum 团队中的开发团队必须一起参与制定“完成”的定义。 每个增量都添加至之前的所有增量上，并且经过彻底地测试，以此确保整合在一起的所有 增量都能工作。 随着 Scrum 团队的成熟，“完成”的定义会扩大，包含更为严格的标准来保证更高的质 量。当使用新定义时，在先前“完成”增量中可能会发现尚需完成的工作。任何产品或系 统都应该对其上面开发的工作有“完成”的定义。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"Scrum","slug":"Scrum","permalink":"https://createralan.github.io/tags/Scrum/"}]},{"title":"git (一) 基础操作","slug":"git-一-基础操作","date":"2020-01-12T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2020/01/12/git-一-基础操作/","link":"","permalink":"https://createralan.github.io/2020/01/12/git-一-基础操作/","excerpt":"","text":"#GIT 基础 基本操作 git init 在本地初始代码仓库 git clone 克隆远程仓库至本地 git pull 拉取远程代码 git add 添加文件至暂存区 (git add . 添加全部) git commit -m “提交信息” 提交变更至本地 git commit -am “提交信息” 将本地所有改动的文件提交变更至本地PS：Step 6 在没有增加文件的情况下 == git add . + git commit -m “” git push 推送至远程代码仓库 git status 查看相关文件的状态 git reset –soft HEAD~1 回退上次提交 git reset –hard 回退上次所有改动（本地改动的代码也会消失，如果非要执行建议先stash） git revert 撤销一个提交PS：Revert 撤销一个提交的同时也会重新创建一个提交。这是一个安全的方法，因为它不会重写提交历史。相比git reset，它不会改变现在的提交历史。因此，git revert可以用在公共分支上，git reset应该用在私有分支上。你也可以把git revert当作撤销已经提交的更改，而git reset HEAD用来撤销没有提交的更改。 分支 git branch 查看本地分支 git branch -a 查看所有分支PS: git branch -r 无法获取远程分支，ui可以看见分支但是git 命令无法查看原因 git branch -a 这条命令并没有每一次都从远程更新仓库信息，我们可以手动更新一下 git barnch -r 查看远程分支 git checkout 切换分支 git checkout -b &lt;分支&gt; 创建并切换分支 git checkout -b &lt;分支&gt; origin(远程仓库名字)/DEV(基于的分支名称) 切换远程分支 git merge &lt;分支&gt; 将当前分支及目标分支整体当做一次提交，完成后HEAD有两个parent git rebase &lt;分支&gt; HEAD移至当前分支顶端,将目标分支的所有提交记录依次执行到当前分支中，执行完成后目标分支仅作为改动副本,不会产生两个parent PS：git切换成默认源npm config set registryhttps://registry.npmjs.orgnpm config set registry https://registry.npmjs.org","categories":[{"name":"git","slug":"git","permalink":"https://createralan.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://createralan.github.io/tags/git/"}]},{"title":"敏捷开发方法(五) Demo演示原则","slug":"敏捷开发-五-Review规范","date":"2019-12-29T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2019/12/29/敏捷开发-五-Review规范/","link":"","permalink":"https://createralan.github.io/2019/12/29/敏捷开发-五-Review规范/","excerpt":"","text":"Sprint Demo优点1.团队的成果得到认可2.其他人了解团队在做什么3.吸引相关人员注意，得到反馈4.使团队完成100%的工作，而不是99% Sprint Demo 原则1.目标清晰2.不要花太多时间准备3.节奏要快4.注重表示业务层，而不是技术细节5.不需要演示bug和微不足道的小特性 会议准备 评审会议之前，由测试人员准备本迭代成果的演示环境，PO/需求人员协作测试团队准备演示数据，脚本等。 演示环境建议使用独立的环境，非开发环境。 评审会议之前，PO/需求/测试保证所有迭代已验证条目部署到演示环境。 基于用户业务场景设计演示的操作线路，并保证覆盖到该场景下所有的待演示条目。 PO确定并邀请参会人员，通常有：Scrum团队（PO、SM、开发测试、UE/UI、敏捷教练）、用户/用户代表、其他相关干系人（如：产品线相关人员、管理人员等）。 会议资料通常有：Sprint目标、Sprint backlog等 完成情况说明及产品演示 首先由SM描述本迭代目标,确保参会人员都了解目标。 SM说明本迭代开发任务完成情况，及未完成的原因说明，需求/UE协助补充验证情况，测试依据测试报告补充测试情况。 通常由测试人员依据《Sprint backlog》进行产品演示； 参会人员根据上述演示及说明提出疑问，Scrum团队进行回答，并记 录发现的问题及期望的改进，改进可能是新的功能需求或一个功能的调整完善。 用户/PO最后依据产品演示、需求/UI/测试的验证情况，接受或拒绝 Sprint开发成果。 根据1）中的记录及2）的结果调整PBI。会后根据评审通过情况进行基线标识。 会议输出 《Product Backlog清单及验证》/《Sprint Backlog清单及验证》 《Sprint验证问题一览表》《标识Sprint基线清单》 评审会规则 迭代评审会在迭代结束前的最后一天进行，不能延期； 评审会议时间，建议根据迭代周期时间，一周对应一小时。 演示过程中，建议不要展开讨论，先记录下来演示结束后讨论。 评审通过标准：用户/PO结合演示情况及测试报告决定是否可交付","categories":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/categories/研发管理/"}],"tags":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/tags/研发管理/"},{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/tags/笔记/"}]},{"title":"敏捷开发方法(四) 用户故事","slug":"敏捷开发方法-四-用户故事","date":"2018-10-29T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2018/10/29/敏捷开发方法-四-用户故事/","link":"","permalink":"https://createralan.github.io/2018/10/29/敏捷开发方法-四-用户故事/","excerpt":"","text":"目录 概述 概念 实践核心店 用户故事模板 用户故事特征 用户故事三属性 优秀用户故事特征-INVEST原则 建立用户角色模型 用户故事场景 概念 场景类型 场景描述方法 验收标准 用户故事分级拆分 拆分原则 用户故事的大小 用户故事的分级 用户故事拆分 用户故事优先级 用户故事优先级排序介绍 用户故事优先级排序放法 Kano模型 相对权重法 概述概念 用户故事描述了对用户、系统或软件购买者有价值的功能 用户故事描述包含三个要素：角色、活动以及商业价值 描述方式为：作为XXX（用户角色）能够XXX（动作），以便于XXX（目的） 实践核心点 用户故事特性 用户角色建模 用户故事场景 用户故事验收标准 用户故事等级&amp;拆分 用户故事优先级 用户故事模板作为一个用户故事，必须包含如下的内容： 主题：采用三段论的方式进行用户故事描述。 描述：对故事的详细描述： 故事场景 业务流程 验收标准 优先级 估算值 用户故事特征用户故事三个属性用户故事描述了对用户、系统或软件购买者有价值的功能。其包括： 描述：总体描述，用来做计划和行为提示，用户故事描述包含三个要素：角色、活动以及商业价值 描述方式为：作为XXX（用户角色）能够XXX（动作），以便于XXX（目的）其中： 用户角色：谁要使用这个功能，在本指南中可以采用用户建模中的角色； 活动：需要完成什么样的功能； 商业价值：为什么需要这个功能，这个功能带来什么样的价值。 有关故事的具体化细节: 故事相关活动的细化说明，主要包含的内容. 在这个故事中，每个角色需要参与的工作（活动）及实现的结果； 在这个故事中，每个角色的工作流程； 每个工作流节点的具体工作内容及具体业务控制逻辑要求和逻辑条件。 包括在故事在团队讨论中内容形成的注释。 验收标准：用于表达和明确故事细节且可用于确定故事何时完成，用于明确团队完成故事的标准。 提示:用户故事要使用用户可以接受的业务语言来描述故事，不能够使用技术语言来描述。用户故事的质量是后续工作顺利完成的基础，因此尽可能保证用户故事的质量，不要因为用户故事的不清晰使得在开发中过多的投入到故事论述中，导致开发结果没有完成。 优秀用户故事特征-INVEST原则 I – Independent，独立性，可独立交付给客户：要尽可能的让一个用户故事独立于其他的用户故事。用户故事之间的依赖使得制定计划，确定优先级，工作量估算都变得很困难。通常我们可以通过组合用户故事和分解用户故事来减少依赖性。 N – Negotiable，可协商性，便于与客户交流：一个用户故事的内容要是可以协商的，用户故事不是合同。一个用户故事卡片上只是对用户故事的一个简短的描述，不包括太多的细节。具体的细节在沟通阶段产出。一个用户故事卡带有了太多的细节，实际上限制了和用户的沟通。 V - Valuable ，价值性，对客户有价值：每个故事必须对客户具有价值（无论是用户还是购买方）。一个让用户故事有价值的好方法是让客户来写下它们。一旦一个客户意识到这是一个用户故事并不是一个契约而且可以进行协商的时候，他们将非常乐意写下故事。 E - Estimable ，估算性，能估计出工作量：开发团队需要去估计一个用户故事以便确定优先级，工作量，安排计划。但是让开发者难以估计故事的问题来自：对于领域知识的缺乏（这种情况下需要更多的沟通），或者故事太大了（这时需要把故事切分成小些的）。 S - Small ，短小：分解到最底层的用户故事粒度尽量小，至少在一个迭代中能完成，一个好的故事在工作量上要尽量短小，最好不要超过一个迭代周期的工作量,要确保的是在一个迭代中能够完成。用户故事越大，在安排计划，工作量估算等方面的风险就会越大。 T - Testable，可测试性:一个用户故事要是可以测试的，以便于确认它是可以完成的。如果一个用户故事不能够测试，那么你就无法知道它什么时候可以完成。一个不可测试的用户故事例子：软件应该是易于使用的。 建立用户角色模型建立用户角色模型即梳理用户角色:把客户和开发人员聚集到一个房间中，通过头脑风暴，列出初始的用户角色集合，然后整理最初的角色集合，通过整合角色和提炼角色，最终确定出使用软件的角色。 具体操作方法可以参考如下： 所有相关人员包括开发人员、需求人员、客户等均聚集在一起，通过头脑风暴首先列出原始的用户角色： 只需要在卡片中写出自己想到的角色，不需要讨论和评估； 将卡片读出来，粘贴到展示板中； 直到大家没有新的角色提出； 要注意列出的角色是产品实际使用用户。初步分类：将第一步形成的用户角色进行初步分类，形成角色集合： 将卡片进行初步分组，标明角色间的关系； 相同的进行重叠； 包含关系通过卡片的覆盖进行体现； 系统角色尽量是一个具体的人。整合角色： 去掉完全重合的卡片角色，讨论中可能会新增新的卡片； 丢弃对系统不重要的角色。提炼角色，建立角色卡片： 经过前期的讨论，已经对角色之间的关系有了基本的了解； 通过提炼的角色，描述角色特征，角色特征可以从如下几个方面进行考虑： 用户使用软件的频率； 用户在相关领域的知识水平； 用户使用软件和计算机的熟悉程度； 用户使用该软件的目标和特点，如用户特别关注便捷性、关注用户体验； 本软件对该用户有帮助的特征； 将特征形成用户角色特征卡片。 为了让角色更加完整，在用户故事后续重更加生动准确。可以进行如下两个角色的补充，根据产品实际情况进行，非必需。 虚拟角色：虚构出一个实际用户，阐述他的特点和可能使用的场景，该角色需要真正代表产品的目标客户，作为软件虚拟使用人员，可以配以名字、照片、相关信息描述，在项目中可以理解为是真实存在的。 极端角色：可以找到一些遗漏的故事，根据产品需要决定是否有必要； 用户故事场景概念定义：从用户的角度出发，描述了一组典型用户在典型工作环境下的典型需要、想法、工作习惯等，是指一个应用(通常就是你的那个产品)被使用的时候，用户“最可能的”所处场景。 用户故事场景的设计，主要从以下几个方面考虑： 对每一个场景，设计一个场景入口，就是描述场景如何开始 用户故事主要是描述典型用户在这个场景中所处的内部和外部环境（内部环境指心理因素等） 需要给场景划分优先级，并按优先级排序 用户场景有大有小，适度、平衡即可 用户和系统有成百上千种可能的交互情况，在写场景的时候要有针对性用户故事场景的特征： 场景的背景： 典型用户 用户的需求、迫切需要解决的问题 假设 行业背景等 场景：关于这个场景的文字描述：要列出这故事中出彩的地方, 例如：软件的哪些功能让用户特别满意? 逻辑和界面设计要注意哪些因素? 第一次使用的用户和多次使用的用户在体验上有何区别对待? 其他参考资料（工作规程、组织机构图、工作职责清单等）场景通常在限定的条件内而存在，场景包括时间、空间、设备支持、社交及用户情绪等多个方面，进行应用场景的判断和描述的时候，尽量把这些都考虑完整。 场景的类型 基于故事目标或者任务的场景：主要描述用户想做什么，不包含用户如何完成任务的任何信息。 精细化的场景:提供了更多的用户使用细节。这些细节能帮助团队更深入的理解用户特点。 全面的场景描述:场景和人物角色还可以结合起来，分类呈现不同类型的用户使用产品的原因，有什么样的需求，揭示出“什么样的人”在“什么样的场景”下会有“什么样的行为”。 测试场景:说明预期的用户是如何完成这个任务的所有路径和步骤，包括用户可能使用的主要的入口或者其他的入口，供观察人员和记录人员在测试中使用。而在测试后，可对比下你的预期过程和用户完成任务的真实过程。 场景描述方法场景描述中需要明确： 环境-人员-事情-产生的价值； 用户故事可以采用卡片、故事访谈链接、用户场景截图、故事板等方式表达故事的场景 验收标准验收标准：定义故事是否完成的标准，让团队和产品负责人对此达成一致 面向用户的价值设定验收标准，业务验收标准主要包含： PO或需求从业务的角度描述此功能的验收标准，在故事进入迭代计划之前该验收标准明确清晰； 按照用户的需要，产品Backlog条目完成； PO或需求在Sprint结束时接受或拒绝接受开发团队的工作成果，对每个演示的故事和主要缺陷，PO表示接受（符合预期和验收标准）或拒绝（不符合预期或不满足验收标准），并给予团队反馈或意见； PO或需求根据用户的价值确定功能优先级，并确认功能已经开发完成； PO确认已经达成产品的投资回报率(ROI); 用户故事分级拆分拆分原则 缩短完成用户故事的时间； 减少用户故事大小的差异性； 采用逐级分解细化方式，最终拆解为用户故事。 用户故事的大小用户故事的大小与完成时间不是成正比的，故事增加两倍，投入时间可能增加5倍；当前我们通过时间盒的方法控制用户故事的大小。目前我们的要求是：用户故事大小不能超过迭代周期。 史诗：通常为大一点的用户故事，通常分为两种 复合故事（compound story）：由多个小的故事组成； 复杂故事（complex story）：本身就很大且不容易分解的故事。 通常通过分层的方式体现，有些需要采用探针实验进行验证 用户故事的分级用户故事可以两个维度进行划分：一个是产品展现形式，一个是产品颗粒度。 产品展现形式分为以下三部分： 客户可见: 产品史诗、产品功能、产品增强，描述产品的卖点(展现给客户) 产品经理可见: 产品优化、产品约束、产品条件、产品性能等 开发团队可见三部分进行区分：产品缺陷，产品重构 产品颗粒度采用树形结构的形式进行细分，上级故事也可称为史诗级别的故事。 用户故事拆分主要是要从客户角度对用户故事进行划分，具体可以： 按照不同操作— 即根据动作对故事进行分解，添加、删除、修改、浏览等 按照数据—即根据数据边界进行分解，可以浏览产品名和介绍、可以浏览产品价格 按照特性—易用性、性能、兼容性、并发性等等 按照角色—从不同用户角度按照投入的人力 - 比如要完成信用卡支付(Visa, Master, AmericanExperess)，可以分成三个故事来实现 按照实现复杂程度、步骤—解为探针实验调研以及实现两部分进行分解； 按照流程: 即根据业务流程进行分段，明确输入输出 产品缺陷：分为两类，一类是客户发现的，需要展现给用户，一类是我们自己发现。 用户故事优先级用户故事优先级排序介绍PO负责排序Story，产品总监负责排序Eipc和拍板有争议的story，排列优先级时需要考虑下面几点： 大部分用户和客户对特定特性的渴望程度 小部分重要用户和客户对特定特性的渴望程度 故事之间的互补或依赖关系 用户故事优先级排序放法Kano模型我们根据用户需求重要性将需求分为三种类型：基本型需求&gt;期望性需求&gt;兴奋型需求，这三种需求根据绩效指标分类就是基本因素、绩效因素和激励因素。 需求类型 定义 不满足时 满足时 兴奋型需求 要求提供给顾客一些完全出乎意料的产品属性或服务行为，使顾客产生惊喜 当其特性不充足时，并且是无关紧要的特性，则顾客无所谓 当产品提供了这类需求中的服务时，顾客就会对，产品非常满意，从而提高顾客的忠诚度 基本型需求 顾客认为产品“必须有”的属性或功能 当其特性不充足（不满足顾客需求）时，顾客很不满意 当其特性充足（满足顾客需求）时，无所谓满意不满意，顾客充其量是满意 期望型需求 要求提供的产品或服务比较优秀，但并不是“必须”的产品属性或服务行为有些期望型需求连顾客都不太清楚，但是是他们希望得到的 当没有满意这些需求时，顾客就不满意 在市场调查中，顾客谈论的通常是期望型需求，期望型需求在产品中实现的越多，顾客就越满意 通过两个问题确定功能的分类： 关于产品中具有这项功能，用户会觉得怎样­——功能存在形式 关于产品中没有这项功能，用户又会觉得怎样——功能缺失形式 对每个问题采用五点度量方式进行问答 我希望这样 我预期就是这样 我没有意见 我可以忍受这样 我不希望这样 答案分类，得到每条需求的分类维护在维度内进行数字优先级排序多人问卷调查，提高准确性实施：通过excel进行。 相对权重法 考虑一项功能所带来的正面益处，和缺乏他所产生的负面影响。评估如果实现它所带来的收益、如果不实现它所会招致的惩罚。 同故事点估算一样，对收益和惩罚也是采用1-9的尺度进行相对度量。 提示： 优先级= 价值百分比/成本百分比 价值百分比= 功能价值/价值总和","categories":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/categories/研发管理/"}],"tags":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/tags/研发管理/"},{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/tags/笔记/"}]},{"title":"敏捷开发方法(三) 看板 vs scrum","slug":"敏捷开发方法-三-scrum对比kanban","date":"2018-10-28T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2018/10/28/敏捷开发方法-三-scrum对比kanban/","link":"","permalink":"https://createralan.github.io/2018/10/28/敏捷开发方法-三-scrum对比kanban/","excerpt":"","text":"Scrum 与 Kanban 对比&amp;选择","categories":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/categories/研发管理/"}],"tags":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/tags/研发管理/"},{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/tags/笔记/"}]},{"title":"敏捷开发方法(二) 看板","slug":"敏捷开发方法-二-kanban","date":"2018-10-27T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2018/10/27/敏捷开发方法-二-kanban/","link":"","permalink":"https://createralan.github.io/2018/10/27/敏捷开发方法-二-kanban/","excerpt":"","text":"概念重点关注 关注可视化和管理流程 不依赖迭代，提倡持续连续工作流，使得团队保持专注 核心概念四个主要原则： 从实际开始；专注增量和渐进性改进 尊重现有方法和角色，培养组织各级领导力 六个核心实践： 可视化工作流程 在制品数量（WIP） 工作项流动 明确规则 确保反馈 建立看板可视化工作流 绘制价值流图：依据团队实际流程，可视化全过程，并通过与上下游协作部门达成共识，进行价值流图向上下游的扩展； 设置输入和输出边界：在设计看板系统的时候要尽早对在制品控制的边界做出决策，对受控范围内的自身团队的工作提供透明度； 分割进行中和已完成，添加必要的缓冲区或等待队列：缓冲或等待队列增大了系统的在制品值，他们将导致前置时间拉长；但是缓冲和队列可以使工作流动变得平滑； 可视化工作项： 可视化价值：上图中的每一个卡片代表一个价值项，它们可以是功能特征、技术任务、缺陷、重构、环境相关等等以开发为中心的一切工作类型； 可视化价值流动：任务卡片所在的列，表示其所处的阶段，价值流是价值项从左至右的流动过程，是信息的产出过程，也是价值增加的过程； 可视化问题及阻碍：价值流动可能会被阻碍，标识阻碍因素（例如用红色卡片对问题和阻碍因素可视化）并推动其解决，促进价值流动； 可视化队列/瓶颈：最终限制系统端到端流量的是系统瓶颈处的流量，必须从解决瓶颈问题开始； 显示化规则团队看板系统建立之初，一项有价值的实践必不可少，显示化团队工作的规范，规则。显示化流程规则，是指明确定义和沟通团队所遵循的流程规则，从而让团队和利益干系人就工作协议达成一致。 价值项的“流转规则”是看板系统中最典型流程规则，它定义了一个价值项从一个阶段进入下一阶段所必须达到的标准。 图中，给出了某团队其中价值流转规则的实例，例如流程规则2定义了从UE设计阶段进入待开发开发阶段所必须达到的条件。“流转规则”的显式化，让质量内建于各个阶段——这与精益制造中内建质量的思想是一致的。某些团队使用DoD（定义完成标准）做流转规则不失为定义“流程规则”的简便方法，但应该注意的是流程规则可能需要随着团队和流程改进调整。 除“流转规则”外，其它重要的规则也可以或者需要被显式化，如，团队的工作纪律，协作规则、优先级的定义规则，缺陷处理策略，输入节奏，交付节奏等，我们称之为其他规则。 “流程规则”和“其他规则”可以让研发相关活动有序保质的完成。 初始化在制品限额(WIP） 在制品限额: 明确限制流程中每个状态上最多同时进行的任务数，是看板方法中的一个核心机制，如下图所示，列标题上面的数字标识了该阶段允许的在制品的最大数目； 设置在制品限额的目的： 优化价值流动：限制在制品数量，减少了价值项在阶段间的排队等待，缩短了价值从进入系统到交付的时间，加速了端到端的价值流动； 暴露问题：限制在制品数量，让过去被隐藏的问题，如团队协作不良、需求定义错误、开发环境低效、资源分配不均衡等得以显现； 初始化在制品限额： 工作任务的在制品限额应该按照每个人、每个开发结对或每个协同工作的小团队的平均工作项数量来设置，一般而言，限额数值应该控制在1~3人（/结对/团队）范围内比较合适，业内推荐限额设置公式为 2n-1（n为人数/结对数/小团队数）； 可以将工作任务一栏和完成队列归在一起，合并计算在制品限额；缓冲区的限额越小越好，但是其大小要确保瓶颈资源得到充分利用，并足以维系系统中的稳定流动； 无需浪费时间试图设定一个完美的在制品限额大小，初始化之后，需要在使用过程中不断的试验进行调整； 在制品限制形成的拉动机制：在制品数目小于在制品限额时，才可以从前一阶段拉入新的工作。上图中，开发阶段的在制品限制数目是14，而实际在制品数目是6，可以拉入新的工作；需求验证阶段的在制品数是3，达到了上限，就不允许拉入新工作 创建物理看板 使用看板使用看板进行协调可视化控制和拉动 首先，在制品限额。即我们看到的每一个栏目上标示的限制数字。我们要控制在那个栏目下区域卡片的数量，不能超过在制品限额的数量。例如图四中UE（2）栏目的在制品限额=2，当前没有卡片在那个区域，我们可以从输入列中拉入2张卡片到UE栏目，并开始UE设计工作。 其次，拉动策略。当我们要从输入列中拉入卡片时候，需要根据拉动策略，如工作项类型，到期日，工作项在队列中停留的时间，以及优先级选择合适的卡片到UE栏目。拉动并不是随便拉动，需要根据拉动策略选择工作项。 最后，工作项受阻和延期。根据进入队列的时间和实际日期对比，可以判断出某个工作项是否长期滞留或者受阻。一旦工作项受阻，需要将受阻问题卡片黏贴到这个工作项上以作标示。受阻问题卡片常见表现为，前置工作项卡片，管理问题卡片，或者缺陷卡片。团队需要优先排除受阻问题。让受阻工作项流动起来。 每日站立会 每日站立会是看板管理中的一项活动，聚焦在工作项的流动性问题的协调和解决。会议的组织者一般是项目经理或产品经理，参与人员为一为包括，业务，需求，设计，测试和看板上参与价值流产生和传递的干系人。 站立会的步骤一般是组织者先进行看板的走读。所谓看板的走读，即从后往前，从右到左逐一检查栏目下空间的工作项卡片，主要关注在制品限额是否已经到达上限和受阻和延期的工作项。组织者针对看板的受控项提出问题。然后团队成员简短讨论产生问题的原因，解决方案，并承诺何时可以解决该问题。另外，针对影响流动的其他并未在看板上展示出来的问题组织需要相关人员会后讨论，并协助最终把问题解决。 这种关注流动性问题的站立会，可以让更多人参与进来，同时不会导致会议时间持续过长，我们建议站立会大约15分钟左右。 另外，看板每日站立会来源与Scrum敏捷开发过程中的每日站立会，由于看板上关注了价值流转换中每个人的具体的工作项，每个工作项都可以看到当前的负责人，所以不必再让每个人讲述，昨天做什么，今天计划做什么，遇到了什么障碍类似的问题。需要特别注意的是工作项卡片上必须标示了当前工作项的负责人 调整在制品限额 如果一开始将在制品限额设定得过低，这时候团队可能会发现，在看板墙上可以看见大量代表问题的阻碍项，过小的在制品限额意味着几乎每一件事情都会变得举步维艰，许多人会无事可做而处于空闲状态；例如：开发队列的在制品限额我们设定为4，但是我们有5个开发人员，这样的在制品限额就有可能造成开发人员的产能剩余，工作闲置； 相反的，如果在制品限额设定得太高，那就不能起到在制品限额的可视化问题及预警作用，可能直到问题失控才会引起大家的重视； 例如，下图中开发队列的在制品限额我们一开始设定过高（14），开发的队列不断输入，过了一段时间之后，我们会发现过多的开发造成了等待队列的大量堆积，整个看板系统的流通遇到瓶颈，在这种状况出现之前，我们就应该通过合理的在制品限额来暴露问题 对于能力比较强且有较高成熟度的组织，由于预期之外的问题很少，所以可以考虑采用约束较为严格的在制品限制规则，对于成熟度较低的组织，把在制品的限制规则设得比较宽松为好，开始时，设得大一些，通过创建持续改进的驱动力，将其逐步调低，所有的在制品限额都需要通过看板系统不断的试验进行调整； 在有了相对合适的在制品限额后，可能会有一些意想不到的变异性因素会导致上游步骤变成一个临时瓶颈，看板系统在该处的在制品限额会让整个工作流停下来解决该处的瓶颈，避免系统产生赌塞和过载，当障碍被排除时，系统便可重新恢复流动； 建立交付节奏交付节奏是指以固定频率交付可用软件的模式。稳定交付节奏十分重要，定期交付有利于建立信任，缺乏可预测性会破坏信任。同时能够引导团队能够围绕交付目标开展工作，并降低了每次交付的协调成本，提高工作效率。 Scrum使用固定时间盒sprint来获得稳定的节奏，一般1-4周。迭代开始时候，确定代办项，然后开始一系列的分析，设计，开发，测试，重构等活动，这些活动都要基于假设代办项粒度足够小，并假设上述一系列活动都可以在时间盒内完成。 看板方法抛弃了固定时间和概念，把优先级排序，开发，交付等活动分离开来，分别对待这些活动，允许每种活动根据自身特性来调整节奏。同时看板方法更倾于更频繁的交付节奏，甚至可以支撑随需或者临时交付。 看板对于交付节奏的处理，主要把创建故事或需求条目的时间点与交付频率分离开。当准备交付时，其他工作仍然处于进行中状态。即输入节奏和交付节奏分离。好处显而易见，由于故事优先级排序活动参与人与交付活动参与人可能有不同，协调活动也不一样，按照各自的节奏和方式工作效率更高。 确定交付节奏并非一件容易的事，交付需要付出协调成本和事务成本，同时要考虑带来的市场价值。频发发布可以降低市场风险但会增加发布成本。假设50人团队，一次发布需要抽出10人投入3天来完成一次代码的交付，那么2周一次发布频率可能带来的成本较高。所以选择怎样的发布频率要根据实际情况来定义。 看板使用过程中，会逐渐形成适合团队的发布频率，也要不断提升效率提升交付节奏。 建立输入节奏 输入节奏：与参会干系人达成共识的定期召开会议的时间间隔，会议中按照优先级来选择代办请求项，填充到持续工程的输入队列中以便开发，通常我们也把这种活动叫做优先级排序节奏； 确定优先级排序节奏：节奏固定的优先级排序：通过与参加优先级排序决策的所有干系人达成一致的以合适的频率定期召开会议，建立优先级排序节奏；一般的建议是，这种会议越频繁越好，这样，输入队列就会越小，从而使系统中的浪费越少，在制品越少，前置时间越短，与此相关的成员和组织间就会更频繁的开展协作；要努力寻找开销最小且最为有效的可能的协调方案，合理情况下，越频繁举行的优先级排序会议越好； 随需或临时性的优先级排序：以固定频率定期召开优先级排序会使事物成本及协调成本逐步降低，而对于会议的效率和节奏都很高的高成熟度组织，可以选择随需或者临时进行的优先级排序； 度量看板度量和管理工作流看板系统是可预测的，专注于保持系统的顺畅流动。物理看板可以提供基本的度量数据，包括在制品数量，前置时间等，同时可基于累积流图进行分析和障碍的解决。电子看板为管理提供了更多的度量数据，为团队的管理和报告提供支撑。 度量元 度量方法累积流图 左面的斜线是累积已经开始的价值项（如用户需求）数目； 右面斜线是累积完成价值项的数目； 两条斜线的垂直距离表示某个时刻已经开始但还没有完成的价值项数目，也就是在制品数量； 两条斜线的水平间距表示价值项从开始到完成的平均前置时间，也就是从概念到交付的响应时间，它是价值流动效率的一个重要衡量； 在制品数量与周期时间成线性关系：在制品数量减少，带来平均前置时间缩短，即流量速率的提升； 斜线的斜率反应的是价值流量速率，也就是每周（或固定时间段内）可以交付的价值项数量，这里的价值可以是故事点数、功能点数等等，团队或组织的目标是要持续提升交付速率； 可以识别工作中的瓶颈：在开发的流程中，我们可以将其中每个不同环节（分析、实现、测试、部署、完成）的工作项数量用不同*颜色的带状区域可视化出来，观察一下，是否有一个区域的在变窄，同时在流程中相对于这个环节之前的环节正在变宽（说明队列正在增长，如下两图示例），如果我们看到了这种情况，我们就在吞吐量最低的地方找到了瓶颈，着手去解决它。 准时交付率通过将预估前置时间和实际前置时间进行对比，展示的是团队的可预测水平，度量一个工作项是否能够如期或者提前交付，估算的准确性是表明系统是否高效运行的一个信息指示器；我们也可以通过度量最近月份以及年度的准时交付率，来判断团队交付能力趋势的提升 初始质量缺陷意味着成本，它会影响看板系统的周期时间和流量速率，度量缺陷与在制品总量和流量速率的趋势是有意义的，我们期望看到缺陷率越来越低，同时周期时间和流量速率不断提升","categories":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/categories/研发管理/"}],"tags":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/tags/研发管理/"},{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/tags/笔记/"}]},{"title":"敏捷开发方法(一) Scrum","slug":"敏捷开发方法-一-scrum","date":"2018-10-26T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2018/10/26/敏捷开发方法-一-scrum/","link":"","permalink":"https://createralan.github.io/2018/10/26/敏捷开发方法-一-scrum/","excerpt":"","text":"Scrum团队-三大角色Scrum团队：由产品负责人、开发团队和Scrum Master组成。 是跨职能的自组织团队 自组织团队自己选择如何最好地完成工作，而不是由团队外的人指导 跨职能团队拥有完成工作所需要的全部技能，不需要依赖团队以外的人 这种团队模式的目的是最大限度地优化灵活度、创造力和生产效率 三大角色： Scrum管理-五事件Scrum 管理: 所有事件是有时间盒限定的 每个事件都有时间限制的 一旦Sprint开始，它的周期也就固定下来了，不能缩短或者延长 Scrum 管理五事件包括： Sprint 计划会议 站立会议 回顾会议 演示会议 Scrum管理实施步骤指南（1） Sprint 回顾会议会议准备 会议物品：白板、便签纸、笔等； 会议资料：通常有《Sprint任务清单》《站立会议问题跟踪表》、《Sprint验证问题一览表》、《燃尽图》 参会人员：PO、SM、Team、敏捷教练； 会议组织：可由SM，或敏捷教练，或任一团队成员组织。 会议氛围：愉悦的环境，如：可采用简易茶话会的形式，促进团队成员轻松打开话题，畅所欲言，也可促进团队成员放下手中的其他工作，把思路带到会议中 会议过程 会议组织者介绍会议目标及会议进程。明确会议规则：回顾会要求每个人都参与，做完一个迭代肯定有感受的，调动大家进行坦诚交流。 上一迭代回顾：将站会问题一览表、燃尽图、验证问题一览表等的问题进行整理回顾，哪些做了，哪些没有完成，遇到了哪些问题。 团队总结：团队成员根据上述展现的情况及自身感受，在便签纸上分别写出认为上一迭代团队或个人做的“好的”及“可改进的”两类意见，两方面各写一条。注意‘可改进’的问题最好写能够改进的。之后由大家逐一讲解便签条内容，并贴到白板相应的一列上。这里要求每个人都要写下来，避免说过就忘了。 确定改进项：团队成员针对每一位提出的问题逐一投票，每人投三票,票数最多的三个问题将在下一跌代解决。之所以定义为三个问题，因为根据业内经验超过三个问题在一个迭代里很难有效解决。 改进措施：强调共同分析，这一过程会将问题提到客观全面的高度，让团队能够更清晰的认识到问题的实质，进行问题分析。问题分析可用到的方法及工具应有很多种，比如头脑风暴、鱼骨图等。对于新的敏捷团队，敏捷教练也要发挥价值，引入一些好的建议及方法。最后挑选出在下轮迭代中切实可行的改进建议并指定责任人。 问题跟进：下一迭代回顾会议总结开始前，大家一起根据《回顾会议问题一览表》回顾上一迭代问题的解决情况直至问题关闭。具体了解：待改进的问题是否落实并得到了 解决?解决办法是否可行？解决办法是否延用？如果没有得到解决就需要 在本次会议上重新进行讨论分析。也可能在解决别的问题同时已解决掉这个问题。 常见问题Q：是否需要邀请领导参加？A：因为回顾会议需要团队成员打开话题，畅所欲言。有些团队领导参加可能会影响到团队成员说真话。所以需根据团队自身情况决定，如1,2两个迭代过后，团队协作较为顺畅，可邀请领导支持者等参加。 Q：是否可以以远程的形式开展会议？A：远程会议形式不仅耗费沟通成本，效果也会较差，SCRUM的一大特点就是Face To face，所以除特殊情况，还是要找个会议室开。 Q：是否强制要求每个人都要发言？A：要求每个人都发言，做完一个迭代肯定会有感受的，参与才能融入其中。 Q：回顾会议的结果是否需要正式记录？A：需要。回顾会议上最终确定要改进的问题及责任人要整理到书面文档里，发送团队全员。并且在下一迭代回顾会议上进行问题跟进，记录改进措施是否可行，问题是否解决。切实改进问题才能达到回顾会议的效果。 Scrum管理实施步骤指南（2） Sprint 计划会议会议准备 邀请与会者：产品负责人、Scrum Master、团队所有成员 在sprint计划会议之前，要确保产品backlog的井然有序（已按优先级排列的产品 Backlog ） 把产品 Backlog 公开给会议中的每个人，保证其可被获取 保证房间环境适合小组讨论，一个比较安静的会议室，有投影仪 每个人都可以获取上次 Sprint 评审会议和 Sprint 回顾会议的结果 用作计划纸牌的卡片 一个任务看板 会议进程第一部分：产品负责人和团队一起，在先前评估的成果基础上，定出 Sprint 目标和Sprint Backlog，决定在Sprint中需要完成哪些工作。 SM把 Sprint 完成周期公开给所有人 SM把 上一次Sprint 评审会议的结果公开给所有人 SM把 上一次Sprint 回顾会议的结果公开给所有人 PO向团队产品阐述产品远景，以及达成该远景所需要完成的产品Backlog，让团队成员了解客户的需求。 整个Scrum团队为了更好地了解Sprint的工作进行讨论。 PO和团队一起确认sprint目标。 团队初步确认要放入sprint中的Backlog。(sprint backlog) 第二部分：决定这些工作如何完成，并评估相应的完成时间。 团队从最重要的故事开始逐一讨论每个故事，估算时间。在必要的情况下拆分backlog条目，建议每个条目最好不要超过一天。拆分工作任务，SM带团队拆分 (task) 产品负责人在必要时修改重要性评分，理清每个条目的含义。(拆分sprint backlog 时做的) 产品负责人和团队需要对“完成”有一致的定义。 确定评审会日期 确定回顾会日期 确定每日站会时间和地点 制作任务看板和燃尽图 Sprint计划会议结束时，开发团队最好能够解释他们将如何以自组织团队的形式完成Sprint目标并开发期望的产品 会议输出 Sprint 目标和 Sprint Backlog 任务看板（含燃尽图） 确定好sprint演示日期 确定好sprint回顾日期 确定好时间地点，供举行每日站会 常见问题参会人员哪些是必须的？PO是必须的，产品需求，客户价值就靠他了；SM必须的，他要保证流程，整个环节里面，他是最了解流程的，会议需要他把握节奏，风险等；团队成员更是必须的。三种角色缺一不可。 sprint应该多长才好？经验证明一般2-4周比较合适，可以拥有足够的敏捷性，又让团队进入“流”的状态，团队刚开始要确定sprint的长度，不要浪费太多时间做分析，选一个可以接受的长度先开始再说，等做完一两个sprint再进行调整。 不过，团队确定了最合适长度之后，就要在长时间内坚持住。因为接下来的迭代过程有的时候会稍稍感觉有点长，有的时候感觉有点短。但保持住这个长度以后，它似乎变成了大家共同的心跳节奏，每个人都感觉很舒服。接下来无须讨论发布日期之类的事情，因为大家都知道：每过三周都会有一个发布。 挑选任务的量是多少合适？建议是（Sprint周期）0.8~（Sprint周期） 1.2，防止乐观估计和悲观估计，保证悲观的时候可以完成，乐观的时候有的做。把0.8~1.2之间的内容放到缓冲区中，以备挑选。 Sprint过程中，Sprint backlog是否可以随意添加？由SM进行风险把控，确保整个Sprint不被影响。需要判断添加的backlog优先级，是否紧急，sprint剩余工作量等进行综合考虑。 在sprint计划会议之前，要确保产品backlog的井然有序，是什么意思？井然有序表示的意思是： 所有重要的backlog条目都已经根据重要性被评过分，不同的重要程度对应不同的分数。 无论任何故事，如果产品负责人认为它会在下一个sprint实现，那它就应该被划分到一个特有的重要性层次。 分数只是用来根据重要性对backlog条目排序。假如A的分数是20，而B的分数是100，那仅仅是说明B比A重要而已，绝不意味着B比A重要五倍。如果B的分数是21而不是100，含义也是一样的。 最好在分数之间留出适当间隔，以防后面出现一个C，比A重要而不如B重要。当然我们也可以给C打一个20.5分，但这样看上去就很难看了，所以我们还是留出间隔来。 是否可以把一个产品backlog当做一个Sprint backlog？看情况而定，如果产品backlog就是一个比较小的特性来说，是可以的，如果产品backlog确实很大，那么作为Sprint backlog来说，就不太合适了。建议每个Sprint backlog最好不要超过一天。 Scrum管理实施步骤指南（1） Sprint日站立会议会议准备 确定会议主持人：SM或团队成员轮流。 确定参会人员：团队所有成员、Scrum Master、产品负责人（可选）、相关人员（可选）。 选择一个合适的固定地点，便于团队成员站立围成一圈进行交流，建议选择靠近团队办公的地点。 确定一个合适的固定时间，便于团队成员养成一个习惯，这样就不要每次开会都要下通知了，建议每日早上9:00。 每日站会时要有任务看板，在看板上粘贴本项目组的任务状态和任务工作量：未开始的任务，进行中的任务，完成的任务。也可以借助一些敏捷的工具，例如JIRA系统，可以电子化sprint backlog。物理看板更有视觉的冲击力，电子看板更便于查询、统计、度量和优化。团队成立初期可以采用物理看板，后续团队在持续迭代的过程中需要进行过程数据分析，以便不断改进优化，电子看板将必不可少 会议进程（15 分钟内） 主持人召集并控制会议时间，会议中注意引导话题，如果相关人员想发表些言论，礼貌地提醒他，该会议只允许让小组成员讨论。 会中团队成员每个人就3个问题回答，并且更新每个任务的进展状态，直接在白板上移动任务贴纸： 昨天我为开发团队达成Sprint目标做了什么？（要关注细节，又不能过分详细） 如果任务状态为已完成，把任务从“待处理”或“处理中”转为“已完成”状态； 如果任务状态为进行中，把任务从“待处理”转为“处理中”状态； 如果任务状态已经是“处理中”，需标明剩余工作量，并说明是否存在阻碍任务完成得问题； 如果任务不在 Sprint Backlog 上，添加这个任务，并标明工作量。 今天我准备如何帮助团队达成Sprint目标？ （当成员间的工作有依赖关系时，会给其他成员一个很好的提醒） 如果任务状态为“待处理”转为“处理中”状态 如果任务状态已经是“处理中”，，需标明剩余工作量，说明是否存在阻碍任务完成得问题 如果任务不在 Sprint Backlog 上，添加这个任务，并标明工作量 遇到有什么事情阻碍了我帮助团队达成Sprint目标？（让团队成员认识到在任何任务中他们都不是孤立的） 如果有阻碍团队开发进度的问题，把该障碍加入到障碍 Backlog 中。 如果有问题需要讨论，但只需要几句话的讨论，那么在会上解决；否则需要详细讨论的，记下来，单独安排一个会议专门讨论。 在会议结束时，主持人计算剩余的工作量，更新燃尽图，预测达成Sprint目标的可能性，可以做个简短的总结，我们在何处？我们离目标有多远？ 会后SM要及时解决会议上提出的问题，否则会影响大家，反映问题的积极性。 会议输出 得到最新的障碍 Backlog 得到最新的 Sprint Backlog 最新的燃尽图 常见问题每日站会有必要每天召开吗？项目的延期源自每天的延期，所以要每天实时跟踪进展，站立会议必须每天都要开。 每日站会可以用邮件代替吗？站立会议重在面对面的沟通，不能用邮件替代，E-mail只会增加沟通成本，而且不能提供细节信息或者给他人问问题的机会。 每日站会仅仅是状态汇报吗？每日站会不是状态汇报，避免团队成员陷入提供状态相关信息的这样一种模式。 真正价值在于优化开发团队达成Sprint目标的可能性，激励团队成员不断地为达成“承诺”而努力。 每日站会项目组外部的管理人员能够参加吗，可以发言吗？站立会议只允许团队成员讲话，项目组外部的管理人员可以列席，尤其是主管领导，但不能发言，不能下指令，只能旁听。在SCRUM中提倡的是团队自我管理。 每日站会可以坐着开吗？不能围在桌子周围坐着开，所有人站立围成一圈，站立暗示这个会会很短，强迫大家更专注和投入，还可以避免有人坐着收发邮件和其他分心的事情。 站立会是向SM汇报吗？不是，成员在回答三个问题时目光要注视着大家，而不是 Scrum Master，否则就变成了向领导汇报工作。对每个人回答的问题有疑问，其他成员都可以提出，而不是只有Scrum Master 一个人在问。大家是平等的，这也是一种文化的培养。 每日会议时间一般多长？应该控制在15分钟之内，如果要讨论技术问题，会后单独开会，少数人参与讨论。 如果有人开会总是迟到怎么办？建议制定惩罚措施，例如每次罚款10元，定期用罚款买一些小零食给团队成员分享，培养团队守时的文化。 Scrum管理实施步骤指南（1） Sprint 评审会议会议准备 评审会议之前，由测试人员准备本迭代成果的演示环境，PO/需求人员协作测试团队准备演示数据，脚本等。 演示环境建议使用独立的环境，非开发环境。 评审会议之前，PO/需求/测试保证所有迭代已验证条目部署到演示环境。 基于用户业务场景设计演示的操作线路，并保证覆盖到该场景下所有的待演示条目。 PO确定并邀请参会人员，通常有：Scrum团队（PO、SM、开发测试、UE/UI、敏捷教练）、用户/用户代表、其他相关干系人（如：产品线相关人员、管理人员等）。 会议资料通常有：Sprint目标、Sprint backlog等 完成情况说明及产品演示 首先由SM描述本迭代目标,确保参会人员都了解目标。 SM说明本迭代开发任务完成情况，及未完成的原因说明，需求/UE协助补充验证情况，测试依据测试报告补充测试情况。 通常由测试人员依据《Sprint backlog》进行产品演示； 参会人员根据上述演示及说明提出疑问，Scrum团队进行回答，并记 录发现的问题及期望的改进，改进可能是新的功能需求或一个功能的调整完善。 用户/PO最后依据产品演示、需求/UI/测试的验证情况，接受或拒绝 Sprint开发成果。 根据1）中的记录及2）的结果调整PBI。会后根据评审通过情况进行基线标识。 会议输出 《Product Backlog清单及验证》/《Sprint Backlog清单及验证》 《Sprint验证问题一览表》《标识Sprint基线清单》 评审会规则 迭代评审会在迭代结束前的最后一天进行，不能延期； 评审会议时间，建议根据迭代周期时间，一周对应一小时。 演示过程中，建议不要展开讨论，先记录下来演示结束后讨论。 评审通过标准：用户/PO结合演示情况及测试报告决定是否可交付 Scrum 三大工件Scrum工件 定义： 以不同的方式表现工作任务和价值，可以用来提供透明性以及检查和调整的机会； 特性： 透明度： Scrum依赖于透明性，所作出的优化价值和控制风险的决定都是基于所获知的工件状态。工件的状态必须是完全透明的，才能为产品作出决定提供一个坚实的基础；否则，作出的决定就是有缺陷的。 “完成” 定义：统一完成标准，团队理解一致； 产品待办列表 一个有序的列表，其中包含产品需要的一切可能的东西，也是产品需求变动的唯一来源 产品待办列表项包含描述、次序、估算和价值； “产品待办列表细化”指的是为列表项补充细节、估算和排序 监控实现目标的进度 产品负责人至少要在每个Sprint评审会议的时候追踪剩余工作总量。 产品负责人比较这个数量与之前Sprint评审时的剩余工作量，来评估在希望的时间点达成目标的进度。 监控预测进度工具： 趋势燃尽图（burn-downs） 燃烧图（burn-ups） 累积型的工作流（cumulative flows） Sprint待办列表 一组为当前Sprint选出的产品待办列表项，外加交付产品增量和实现Sprint目标的计划 Sprint待办列表拥有足够的细节，因此能够在每日站会中对进度的变化有清楚的认识 随着任务的进行或者完成，团队需要估算并更新剩余的工作量 监控Sprint进度 在Sprint中的任意时间点都可以计算Sprint待办列表中所有剩余工作的总和。 开发团队在每日站会时跟踪剩余的工作量，预测达成Sprint目标的可能性。 团队通过在Sprint中不断跟踪剩余的工作量来管理自己的进度。 增量 一个Sprint完成的所有产品待办列表项，以及之前所有Sprint所产生的增量价值的总和； 在Sprint的结尾，新的增量必须是“完成”的，必须可用并且达到了Scrum团队“完成”的定义的标准； 无论产品负责人是否决定真正发布它，增量必须可用； Scrum Master的职责之一：和Scrum团队以及企业一起增加工件的透明性Scrum Master的职责之二：和Scrum团队一起明确团队的完成标准 燃尽图定义是在项目完成之前，对需要完成的工作的一种可视化表示。燃尽图有一个Y轴（工作）和X轴（时间）。理想情况下，该图表是一个向下的曲线，随着剩余工作的完成，“烧尽”至零。燃尽图向项目组成员和管理层提供工作进展的一个公共视图。 燃尽图描述的是项目团队随着时间的推移而剩余的工作量，它能形象地展示当前迭代中的剩余工作量和剩余工作时间的变化趋势，是反应项目进展的一个指示器。这种可视化的管理方式，能够帮助团队工作进展更加透明。 您可以使用物理的白板＋手工更新来维护燃尽图，也可以使用EXCEL来生成和更新燃尽图也可以使用一些的敏捷团队协作工具（如：Leangoo等）来自动生成和更新燃尽图。 维护燃尽图是项目团队的日常工作。一般在每日例会后（对于敏捷研发项目，是指每日站立会）后，团队会根据任务的完成情况对其进行更新。这种可视化、简单易操作的管理方式能够帮助团队提升协作效率，并使团队工作进展更加透明，而过重的管理工具会成为团队的负担。 项目团队可以从燃尽图中识别出当前迭代的风险和问题，以便及时采取对策解决问题、规避风险。 另外，可以通过对多个迭代的燃尽图的持续分析，来对项目团团队进行持续地改进 实施方法燃尽图组成：燃尽图通常由4个核心部分组成 燃尽图横坐标：表示工期； 燃尽图纵坐标：表示要完成的工作； 计划曲线：假定项目组成员工作生产率恒定下的进度曲线； 实际曲线：实际进度曲线。 燃尽图绘制 绘制时间点：在项目组进行完项目计划会议后进行燃尽图的绘制。对于敏捷研发项目来说，是在每个sprint计划会议后进行该sprint的燃尽图绘制 绘制方法：绘制人员：燃尽图绘制和后续的更新，由项目经理指定人员进行。可以是项目经理、SM、QA或团队里的其他成员 绘制方法：在业界用的比较多的绘制方法有二种（针对故事点燃尽、针对工作量燃尽），如下: 步骤1：画出横轴和纵轴。横轴为工期，纵轴为故事点数【或工作量（人天）】。 步骤2：先出第一个点。第一个点，横坐标为开发周期的第一天，纵坐标为这个工期内估计能完成的总故事点数【或总工作量】。这个工期内估计能完成的总故事点数【总工作量】为计划会上估算的最终结果。 步骤3：找出项目计划结束点。计划结束点，横坐标为开发周期的最后一天，纵坐标为0。也就是计划在项目的最后一天“烧尽”至零。 步骤4：连接第一个点和项目计划结束点，产生的这个线就是“计划曲线” 燃尽图“实际曲线”的更新在每日例会后（对应敏捷研发项目，是指每日站立会），项目负责人安排人员计算出剩余工作的估算之和（剩余的故事点数，或剩余的总工作量），然后在燃尽图上画出一个新的点。直至项目结束，停止更新。 读懂燃尽图对于项目团队来讲，燃尽图可以说的上是最有用的一种信息发射源（Information Radiator）。对燃尽图的分析，有助于把握团队的进展情况，另外可以还揭示很多问题，比如团队的表现如何、如何进一步改进等等。 燃尽图有助于回答的问题，例如： 团队的计划制订情况如何？ 在一个Sprint中，团队对计划的故事的执行情况如何？ 团队是自我管理的么？作为“团队”来说，大家的工作步调一致么？ 团队能进行哪些改进？ 可以借鉴和学习一些敏捷大师对燃尽图的分析和总结，来解读各项目自己的燃尽图，Hiren向我们展示了如右图这张图表： 图表中的蓝线 Hiren给出了自己的看法：该团队的计划并不好，因为线根本就没有触到零点，这其中的原因可能有很多。团队的一致性上也出现了问题，他们需要教练。因此，对于该团队来说，计划与自我管理方面亟需改进 图中的紫线表明该团队已经达成了目标，但并没有主动去更新数字，原因可能有二：要么他们太懒了，没有更新剩余的工作量；要么是在该Sprint的最后舍弃了很多用户故事。 图中的绿线表明对于一个计划良好的成熟团队工作量的燃尽情况，该团队是自我管理并且在整个Sprint中拥有足够的故事要去实现。这条线接近于理想情况，表明了软件开发的复杂性。","categories":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/categories/研发管理/"}],"tags":[{"name":"研发管理","slug":"研发管理","permalink":"https://createralan.github.io/tags/研发管理/"},{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/tags/笔记/"}]},{"title":"hexo结合gitpage搭建无限空间静态博客","slug":"hexo结合gitpage搭建无限空间静态博客","date":"2018-10-19T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2018/10/19/hexo结合gitpage搭建无限空间静态博客/","link":"","permalink":"https://createralan.github.io/2018/10/19/hexo结合gitpage搭建无限空间静态博客/","excerpt":"","text":"什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。生成静态网页即可托管到任何支持静态网页的服务器上。 什么是GitPageGitHub Pages 与GitHub同属一个研发组织，免费为你的GitHub项目提供项目部署和托管服务，一个GitHub账号可以创建一个GitPage空间。GitPage支持静态和markdown语法的项目，并与GitHub上的项目实时同步自动渲染。所以你可以很容易使用GitPage搭建自己的博客。 特别注意：一个GitHub账号只能创建一个GitPage空间，并且名称有特殊要求下文详细说明。 可选框架：jekyll 环境准备12nodejsGit 创建github账号和同名项目 申请账号如:wangzhikui 创建同名项目:wangzhikui.github.io 如图: 进入项目的【setting &gt; GitHub Pages】 如图： 按照描述设置开启即可。 到此为止GitPages已经可以使用，提交到wangzhikui.github.io的静态或markdown形式的文件会自动同步到GitPages空间。可通过http://wangzhikui.github.io访问。 配置域名(无此需要可跳过)一、上一步GitPages设置中设置域名如：xiapazi.co二、配置域名的A地址和CNAME别名本域名在阿里云申请，所以登录aliyun.com进入域名配置，域名解析做如下配置 三、项目根目录中添加名为CNAME的文件，内容为 wushuning.com hexo使用安装hexo并使用hexo创建项目安装hexo脚手架工具并使用脚手架创建项目12345npm install hexo-cli -ghexo init xiapaziBlogcd xiapaziBlognpm installhexo server 全局安装脚手架hexo-cli 创建一个名为xiapaziBlog的项目 进入项目目录 安装依赖包 启动服务 服务启动成功出现如下图： 通过http://localhost:4000访问示例程序到此使用hexo创建项目已经完成 手动部署进入项目目录运行命令1hexo g 则会在项目路径中生成一个public文件夹，里边的内容即为hexo为我们生成的所有静态文件。手动将public里边的所有文件git传到CreaterAlan.github.io即可。 到此可通过http://CreaterAlan.bighub.io或域名（如果配置了）http://xiapazi.co访问你的网站。 自动部署打开项目根目录下的_config.yml 找到如下配置:1234deploy: type: git repo: github: git@github.com:CreaterAlan/CreaterAlan.github.io.git 运行命令1hexo d 则将public下的文件部署到CreaterAlan.github.io.git上，我这里只有一个分支master，所以默认，如果要填写分支可以配置repo。建议保持一个分支就可以了。 hexo d 命令push代码使用的是ssh，所以需要配置github的ssh key 关于key生成配置这里不赘述。 注：如果本地要维护两个github账号，这种情况有可能遇到ssh key冲突，该情况在下一篇博文描述 hexo生成的项目目录结构简介使用hexo创建的项目路径如下图： hexo常用命令 命令 简写 描述 hexo server hexo s 启动服务 hexo generate hexo g 生成静态文件 hexo deploy hexo d 将静态文件部署到github上 hexo clean 无 清除缓存文件 (db.json) 和已生成的静态文件 (public) 查看更多命令: hexo 命令大全 本人在部署的时候喜欢使用三个命令组合123hexo cleanhexo ghexo d 使用主题主题文件存放在 /themes下。本博客基于主题hexo-theme-pure 修改而来。大家也可前往hexo 主题库 下载自己需要的主题。 下载主题后放入/thems下 打开项目根目录的配置文件._config.yml.修改配置theme为你主题的文件夹名称即可1theme: hexo-theme-yyy 创建博文通过命令进入项目目录1hexo new test 常见一篇名为test.md的博文，路径在/source/_posts/test.md打开test.md使用markdown编辑即可。 手动创建直接在_posts文件夹下创建一个test.md的文件即可","categories":[{"name":"笔记","slug":"笔记","permalink":"https://createralan.github.io/categories/笔记/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://createralan.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://createralan.github.io/tags/github/"},{"name":"gitpage","slug":"gitpage","permalink":"https://createralan.github.io/tags/gitpage/"}]},{"title":"JAVA编程基础（二）Java性能调优","slug":"JAVA编程基础（三）Java性能调优","date":"2017-11-24T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2017/11/24/JAVA编程基础（三）Java性能调优/","link":"","permalink":"https://createralan.github.io/2017/11/24/JAVA编程基础（三）Java性能调优/","excerpt":"","text":"1.在必要之前，先不要优化这可能是最最重要的性能调优技巧之一。你应该遵循常见的最佳实践，并尝试有效地实现你的用例。但这并不意味着在证明它是必要之前，替换任何标准库或构建复杂的优化。 在大多数情况下，过早的优化占用了大量的时间，使得代码难以读取和维护。更糟糕的是，这些优化通常不会带来任何好处，因为你花费了大量时间来优化应用程序的非关键部分。 那么，你如何证明你需要优化某些东西呢? 首先，你需要确定应用程序代码的速度，例如，为所有API调用指定一个最大响应时间，或者指定在特定时间范围内导入的记录数量。完成之后，你可以度量应用程序的哪些部分太慢而需要改进。当这样做之后，那么请继续看第二个调优技巧。 2.使用分析器来找到真正的瓶颈在你遵循第一条建议，并确定你的应用程序的某些部分的确需要改进之后，问自己从哪里开始? 你可以用两种方法来解决这个问题: 你可以看一下你的代码，从看起来可疑或者你觉得它可能会产生问题的部分开始。或者使用分析器，获取代码中每个部分的行为和性能的详细信息。至于为什么应该总是遵循第二种方法。 答案应该很明显，基于分析器的方法能让你更好地理解代码的性能含义，并允许你关注最关键的部分。如果你曾经使用过分析器，你将会惊讶于代码的哪些部分造成了性能问题。然而，很多时候，你的第一次猜想会把你引向错误的方向。 3 .为整个应用程序创建性能测试套件这是另一个帮助你避免许多意想不到问题的一般技巧，这些问题通常发生在性能改进部署到生产环境之后。你应该经常定义测试整个应用程序的性能测试套件，并在你完成性能改进之前和之后运行它。 这些额外的测试运行将帮助你识别更改的功能和性能方面的影响，并确保你不会发布一个弊大于利的更新。如果你的任务运行于应用程序的多个不同部分比如数据库或缓存，这一点尤其重要。 4.首先解决最大的瓶颈问题在创建了测试套件并使用分析器对应用程序进行分析之后，你就有了一个需要提高性能的问题列表，这很好，但它仍然不能回答你应该从哪里开始的问题。你可以从那些可以快速搞定的开始，亦或者从最重要的问题开始。 当然前者很诱人，因为这很快就能出结果。有时，可能需要说服其他团队成员或你的管理层，性能分析是值得的。 但总的来说，我建议首先着手处理最重要的性能问题。这将为你提供最大的性能改进，而且你可能只需要修复这些问题中的几个就可以解决你的性能需求。 在了解通用性能调优技巧之后，让我们再来仔细看看一些特定于Java的调优技巧。 5.使用StringBuilder以编程方式连接字符串在Java中有许多不同的连接字符串的选项。例如，可以使用一个简单的+或+ =、老的StringBuffer或StringBuilder。 那么，你应该选择哪种方法呢? 答案取决于连接字符串的代码。如果你以编程方式向字符串中添加新内容，例如，在for循环中，你应该使用StringBuilder。它比StringBuffer更容易使用和提供更好的性能。但是请记住，StringBuilder与StringBuffer不同，它不是线程安全的，而且可能不适合所有用例。 你只需要实例化一个新的StringBuilder，并调用append方法在字符串中添加一个新的部分。当你添加了所有的部分后，可以调用toString()方法来检索连接字符串。 下面的代码片段展示了一个简单的示例。在每次迭代过程中，这个循环将i转换成一个字符串，并将其添加到StringBuilder sb的空间中，因此到最后，这段代码写入“this is test0123456789”到日志文件。 123456StringBuilder sb = new StringBuilder(“This is a test”); for (int i=0; i&lt;10; i++) &#123; sb.append(i); sb.append(” “); &#125; log.info(sb.toString()); 正如在代码片段中看到的，你可以为构造函数方法提供字符串的第一个元素。这将创建一个新的StringBuilder，其中包含提供的字符串和16个额外字符的容量。当你向StringBuilder中添加更多字符时，JVM将动态地改变StringBuilder的大小。 如果你已经知道自己的字符串包含多少字符，那么你可以向不同的构造函数方法提供这个数字，以实例化一个具有被定义容量的StringBuilder。这进一步提高了它的效率，因为它不需要动态扩展它的容量。 6.在声明中使用+连接字符串当你在Java中实现第一个应用程序时，可能有人告诉你不应该用＋来连接字符串。如果在应用程序逻辑中连接字符串这是正确的。字符串是不可变的，每个字符串连接的结果存储在一个新的字符串对象中。这需要额外的内存，并降低应用程序的速度，特别是在循环中连接多个字符串时。 在这些情况下，你应该遵循tip 5并使用StringBuilder。 但如果你只是将一个字符串分解成多行来提高代码的可读性，那就不是这样了。 123Query q = em.createQuery(“SELECT a.id, a.firstName, a.lastName ” + “FROM Author a ” + “WHERE a.id = :id”); 在这些情况下，你应该用一个简单的+来连接你的字符串。Java编译器将优化它并在编译时执行连接。因此，在运行时，代码只使用1个字符，不需要连接。 7.尽可能使用基本数据类型另一种避免开销，提高应用程序性能的快速方法就是使用原始数据类型而不是它们的包装类。因此，最好是使用int而不是Integer，或者是double而不是Double。这将让JVM将值存储在堆栈中，以减少内存消耗，并更有效地处理它。 8.尽量避免BigInteger和BigDecimal由于我们已经讨论了数据类型，我们再来看下BigInteger和BigDecimal。尤其是后者，由于其精度高而受欢迎。但这是有代价的。BigInteger和BigDecimal比简单的long或double需要更多的内存，并且大大降低所有的计算速度。因此，如果你需要额外的精度，或者你的数字超过了一个long范围，最好三思而后行。这可能是你在提升性能问题中唯一需要更改的地方，特别是当你正在实现一个数学算法。 9.首先检查当前日志级别这个建议是显而易见的，但不幸的是，你会发现许多代码忽略它。在创建调试消息之前，应该先检查当前日志级别。 这里有两个例子来说明你不应该这样做。 1234// don’t do this log.debug(“User [” + userName + “] called method X with [” + i + “]”); // or this log.debug(String.format(“User [%s] called method X with [%d]”, userName, i)); 在这两种情况下，你将执行所有需要的步骤来创建日志消息，而不知道日志框架是否使用日志消息。在创建调试消息之前，最好先检查当前日志级别。 1234// do this if (log.isDebugEnabled()) &#123; log.debug(“User [” + userName + “] called method X with [” + i + “]”); &#125; 10.使用Apache Commons StringUtils.Replace 代替String.replace一般来说,String.replace 方法工作得很好，而且非常高效，特别是如果你使用的是Java 9。但是，如果应用程序需要大量的替换操作，并且你还没有更新到最新的Java版本，那么检查更快和更有效的替代方案仍然是有意义的。 一个候选就是 Apache Commons Lang’s StringUtils.replace 方法。正如Lukas Eder在他最近的一篇博客文章中所描述的那样，它大大超过了Java 8的String.replace 方法。 它只需要很小的改变。你只需要为Apache’s Commons Lang 项目增加一个Maven依赖项到你的应用pom.xml，并用StringUtils.replace方法替换所有String.replace方法的调用。 1234// replace this test.replace(“test”, “simple test”); // with this StringUtils.replace(test, “test”, “simple test”); 11.缓存昂贵的资源，比如数据库连接缓存是一种流行的解决方案来避免重复执行昂贵或频繁使用的代码片段。一般的想法很简单:重复使用这些资源比一次又一次地创建一个新的资源要便宜得多。 一个典型的例子就是在池中缓存数据库连接。创建新连接需要时间，如果重用现有连接，则可以避免。 还可以在Java语言本身中找到其他示例。例如，Integer类的valueOf方法缓存了- 128和127之间的值。你可能会说，创建一个新整数并不太贵，但它经常使用，缓存最常用的值提供了性能方面的好处。 但当你考虑缓存时，请记住，缓存实现也会产生开销。你需要花费额外的内存来存储可重用资源，因此可能需要管理你的缓存，以使资源能够访问或删除过时的资源。 因此，在你开始缓存任何资源之前，请确保是经常使用。 总结正如你所看到的，提高应用程序的性能有时不需要做大量的工作。这篇文章中的大多数建议，其实只需要稍微的努力就可以将它们应用到代码中。 但通常最重要的建议是很编程语言无关的: 在你知道有必要之前，不要优化 使用分析器来找到真正的瓶颈 首先解决最大的瓶颈问题","categories":[{"name":"java","slug":"java","permalink":"https://createralan.github.io/categories/java/"}],"tags":[{"name":"java性能","slug":"java性能","permalink":"https://createralan.github.io/tags/java性能/"}]},{"title":"设计原则","slug":"设计模式-极简笔记-6大设计原则","date":"2017-10-13T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2017/10/13/设计模式-极简笔记-6大设计原则/","link":"","permalink":"https://createralan.github.io/2017/10/13/设计模式-极简笔记-6大设计原则/","excerpt":"","text":"通过尽量少的语言描述设计模式的相关概念如果想要更详细的描述可参看设计模式其他相关书籍或者资料 6大设计原则单一职责原则英文名称：Single Responsibiity Principle 简称：SRP定义：在定义接口的时候，接口的功能要单一。该原则素来有很多的争议，因为这个原则在实际开发过程中很难界定功能范围，所以需要根据实际情况使用，不要生搬硬套。 里氏替换原则英文名称：Liskov Substitution Principle 简称：LSP通俗定义：只要父类能出现的地方子类就可以出现，而且替换为子类不会产生任何错误或异常该原则主要为继承定义一个规范，子类尽量不要出现父类不存在的方法或属性 依赖倒置原则英文名称：Dependence Inversion Principle 简称：DIP通俗定义：通常依赖都是指的具体实现类的依赖和耦合，这里倒置就是要把依赖放到接口层。具体的实现类之间不存在依赖，实现类只是依赖他们的接口。该原则就是经常谈到的面向接口编程 接口隔离原则英文名称：Interface Segregation Principle 简称：ISP通俗定义：客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。该原则规范了我们对外提供接口时的一个规范，对外提供接口时，只提供需要的接口。比如：提供通过姓名查询用户信息的接口，就提供queryByName(String name),而不是提供一个通用query(String queryParam)，约定参数为{“name”:张三}这样的形式。 迪米特法则英文名称：Law of Demeter 简称：LOD或英文名称：Least Knowledge Principle 简称：LKP本人喜欢第二个描述。通俗定义：一个类再调用其他类或者接口的时候应该对该类有最少的了解，只要知道该接口能实现什么功能即可，至于如何实现，以及过程都不需要关心。 开闭原则英文名称：Open Closed Principle 简称：OCP通俗定义：一个接口，类，模块的定义应该对扩展开放，对修改关闭该原则规范我们在开发过程中尽量通过扩展的方式来实现新的功能或者变化，而不是去修改原有逻辑或者接口","categories":[{"name":"架构设计","slug":"架构设计","permalink":"https://createralan.github.io/categories/架构设计/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://createralan.github.io/tags/设计模式/"}]},{"title":"JAVA编程基础（一）原生实现分页方案","slug":"JAVA编程基础-（一）原生实现分页方案","date":"2015-05-29T00:00:00.000Z","updated":"2020-11-25T02:51:30.649Z","comments":true,"path":"2015/05/29/JAVA编程基础-（一）原生实现分页方案/","link":"","permalink":"https://createralan.github.io/2015/05/29/JAVA编程基础-（一）原生实现分页方案/","excerpt":"","text":"两种分页方式 截取lisit 生成特定分页sql（不同数据库分页sql不同） 方案一 截取list截取list，针对后台查询出来的list数据，前台传入当前页currentPage，每页记录数numPerPage,从而计算出当前页的起始和终止下标，截取list返回前台。 实现： PaginationInfo 分页信息对象 PaginationUtil 分页工具类，传入原始全量list，根据前台传入的页码每页数据量进行截取 如下关键代码 1234567891011121314151617181920212223if(\"pagedemo\".equals(action))&#123;//每页显示数据条数 int numPerPage = 5; //要显示的页int currentPage = Integer.parseInt((String)request.getParameter(\"currentPage\")); StringBuffer json = new StringBuffer(); List&lt;UserVO&gt; list = new ArrayList&lt;UserVO&gt;(); try &#123; //要显示的所有数据 list = userMngService.queryAllUser(); //第一种分页方式，先取所有list，然后截取list分页 PaginationUtil&lt;UserVO&gt; paginationUtil = new PaginationUtil&lt;UserVO&gt;(); PaginationInfo&lt;UserVO&gt; paginationInfo = paginationUtil.listDataProcess(list, numPerPage, currentPage); //要显示的数据 list = paginationInfo.getResultList(); json.append(\" &#123;\\\"total\\\":\"); //数据总数 json.append(paginationInfo.getTotalPages()); json.append(\",\\\"rows\\\":[ \"); for(int i = 0;i&lt;list.size();i++)&#123; . . . . . . &#125; 步骤： 获取前台传参数当前页currentPage, 设置分页规则：每页记录数 获取要显示的所有数据信息list 使用工具类PaginationUtil截取list。返回PaginationInfo对象 PaginationInfo对象中包含了结果relustList页码，总记录数等信息，根据需要取得数据返回json到前台。 方案二 特定分页sql 在需要进行分页处理的DMO类中使用JdbcPaginationDelegator代理类处理，使用PaginationInfo对象存储数据信息。结果list，总页数等示例:123456789/** * 查询所有用户信息 分页 * @param currentPage 当前页 * @param numPerPage 每页显示数据条数 * @return */ Public PaginationInfo&lt;UserVO&gt; queryUserByPageInfo(int currentPage,int numPerPage)&#123; 。。。。 &#125; 步骤： 创建基本查询sql 12StringBuffer sql = new StringBuffer();sql.append(\"select * from ump_user where dr = ?\"); 创建分页信息对象，分页工具代理，如需sql参数创建sql参数对象SQLParameter，如果没有则传null 1234567//分页信息PaginationInfo&lt;UserVO&gt; pagenationInfo = new PaginationInfo&lt;UserVO&gt;();//jdbc分页代理对象JdbcPaginationDelegator&lt;UserVO&gt; delegate = new JdbcPaginationDelegator&lt;UserVO&gt;();//sql参数信息SQLParameter param = new SQLParameter();param.addParam(0); 使用代理对象初始化分页信息 123//使用代理对象初始化分页信息，代理类中会计算总记录数，但是不会执行分页sql，因为很多没有使用元数据没有，vo和数据表的映射//所以没法自动的将rs生成vo，所以，代理只是生成分页特定数据库的分页sql语句，由调用对象自行执行。pagenationInfo = delegate.initPaginationInfo(sql.toString(), param, currentPage, numPerPage); 执行代理类生成的分页SQL 1234//执行代理类生成的分页查询sqlstmt = conn.prepareStatement(paginationInfo.getPageSql());stmt.setInt(1, 0);rs = stmt.executeQuery(); 两种方式对比：两种方案的优劣比较明显，截取list每次都要全查出来，如果list的数据量非常大每次全查耗时较多，可考虑方案二，但是，此方案改动的代码量少，只需要在action加几行代码处理即可。 使用分页sql，方案效率较高，每次只取需要的数据，劣势在于需更改的代码较多，同时如果涉及到多次联查取综合数据的场景则此方案无效，只能使用方案一。","categories":[{"name":"java","slug":"java","permalink":"https://createralan.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://createralan.github.io/tags/java/"}]}]}